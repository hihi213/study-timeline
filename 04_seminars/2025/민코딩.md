- 분야 
	개발자들이라고 다 만들수있는건 아니다 게임개발자는 임베디드를 모른다
	- 임베디드 c
	- web 자바, 자바스크립트
	- 정보보안 자바
	- app 코틀린, 자바 스위프트
	- 게임c++
	- data(이건 세컨드로 가져가라 10년뒤에 먹고 살지 미지수이다)
	다해보고 결정할순 없다
- 비주얼 스튜디오
	- 솔루션 안에 프로젝트가 있다
	- 솔루션과 프로젝트를 동시에 만들고
	- 소스파일안에서 소스파일 만들어 소스짜는거임
	- control+ f5 으로 실행 만약 코드 문제있으면 에러남
	```c++ 암기
	#include <iostream>
	using namespace std;
	int main()
	{
		return 0;
	}
	```
	- trace: 한줄씩만 실행해 버그찾기(디버깅->버그 죽이는 활동)
		- 시작: f10 (창이 디버깅 모드가 됨)
		- 그후 f10으로 한줄씩 '실행'하는거임
		- 종료: shift+f5 누르거나 맨 아래 도착하면
	- 반복문이 있는경우 return있는줄에서 ctrl+f10 누르면(라인까지실행) 반복문 끝난 결과를 보여줌
		- ctrl f10하고 아래에 한번더 하면 그줄까지 실행된 결과를 보여줌 근데 위로 가서 ctrl f10하면 꺼짐(프로그램은 아래로 작동)
		- cout 를 중간중간 껴넣는것보다 빠르다.
		- 아니면 - F9: 중단점 설정-> F5 ->f5누르면 다음중단점 중단점없으면 종료
		- ctrl f5는 중단점에서도 안멈춤
	- 함수 만나면  f11누르면 함수 안으로 들어가짐 (그냥 지나치고 싶을땐 f10)
	-  F10 : 처음부터 한 줄씩 Trace하기 (Step Over, 함수 호출하는 코드에서 F10 누르면 함수 전체를 실행)
	- F11 : 한 줄씩 Trace하기 (Step In, 함수 호출하는 코드에서 F11 누르면 함수 내부로 진입)
	- Shift + F5 : Trace 종료하기 (디버깅 모드 종료)
	
- 빌드후 실행 : ctrl +f5
작성하신 디버깅 단축키와 설명은 전체적으로 정확하지만, 약간의 수정과 정리를 통해 더 명확하게 정리할 수 있습니다. 아래는 정리된 내용입니다.

**Visual Studio 디버깅 단축키 및 설명**

  

**1. Trace (한 줄씩 실행하며 디버깅)**

  

**목적: 코드 한 줄씩 실행하면서 변수 값과 흐름을 확인해 버그를 찾는 활동.**

• **시작: F10**

• 디버깅 모드로 전환하며, 한 줄씩 실행할 수 있는 상태가 됩니다.

• 디버깅 중 한 줄씩 코드 실행.

• **진행: F10**

• 현재 줄을 실행하고 다음 줄로 이동합니다.

• 함수 호출 시, 함수 내부로 들어가지 않고 함수 전체를 실행한 후 돌아옵니다 (**Step Over**).

• **종료: Shift + F5**

• 디버깅 모드를 종료합니다.

• 또는, 프로그램 실행이 끝나면 디버깅이 종료됩니다.

**2. 반복문 디버깅 시 (Ctrl + F10)**

  

**목적: 특정 줄까지 반복문 결과를 빠르게 확인.**

• **Ctrl + F10**: 현재 실행 위치부터 특정 줄까지 한 번에 실행.

• 반복문이 포함된 경우 반복이 끝난 결과를 빠르게 확인할 수 있습니다.

• 특정 줄에서 실행을 멈추고 결과를 보여줍니다.

• **주의**:

• **위쪽 코드로 Ctrl + F10을 실행하면 프로그램이 중단**되므로, 항상 **현재 실행 위치 아래 줄**에서 사용해야 합니다.

**3. 중단점(Breakpoint) 디버깅**

  

**목적: 특정 위치에서 프로그램 실행을 멈추고 디버깅.**

• **F9**: 현재 줄에 중단점(Breakpoint) 설정/해제.

• **F5**: 프로그램 실행.

• 중단점이 있는 경우 해당 지점에서 멈춤.

• 중단점이 없으면 프로그램이 종료될 때까지 실행.

• **Ctrl + F5**: 프로그램을 실행하지만, 중단점에서 멈추지 않고 전체를 실행.

**4. 함수 디버깅**

• **F10 (Step Over)**: 함수 호출 코드에서 **함수 전체를 실행**하고 다음 줄로 이동.

• **F11 (Step In)**: 함수 호출 코드에서 **함수 내부로 진입**해 디버깅.

**5. 디버깅 종료**

• **Shift + F5**: 디버깅 모드 종료.

**6. 빌드 후 실행**

• **Ctrl + F5**: 프로그램을 빌드하고 실행.

• 디버깅 없이 프로그램 전체 실행.

**정리된 단축키 요약**
f9->f5하고 return문으로 커서 움직여서 ctrl+f10하면 중단점에서 그사이 코드를 다 실행하고 return으로 이동함


|**단축키**|**기능**|
|---|---|
|**F10**|한 줄씩 실행 (**Step Over**, 함수 호출 시 함수 전체 실행)|
|**F11**|한 줄씩 실행 (**Step In**, 함수 내부로 진입)|
|**Ctrl + F10**|현재 위치에서 특정 줄까지 실행|
|**F9**|중단점(Breakpoint) 설정/해제|
|**F5**|프로그램 실행 (중단점이 있으면 중단점에서 멈춤)|
|**Ctrl + F5**|프로그램 실행 (중단점 무시, 전체 실행)|
|**Shift + F5**|디버깅 모드 종료|

**추가 설명:**

1. **Ctrl + F10**: 반복문이 있는 코드를 디버깅할 때, 특정 줄까지 빠르게 실행한 뒤 결과를 확인할 수 있어 **cout 디버깅보다 효율적**.

2. **중단점 디버깅(F9 + F5)**: 특정 지점에서만 코드 흐름을 확인하고 싶을 때 유용.

3. **F10 vs F11**:

• **F10 (Step Over)**: 함수 내부로 들어가지 않고, 함수 실행 후 바로 다음 줄로 이동.

• **F11 (Step In)**: 함수 내부로 진입해 세부 동작까지 디버깅.

- 이해를 목표로 하지 말고 능숙해지기 위해 노력하자
- 코딩은 ide에서 웹사이트에서 하지 말자
- 코딩은 할때마다 다 지우고 한다

- if/ for 변수 배열 함수 이 5가지가 c의 90프로다 여기다가 클래스가 추가된게 c++ 
	- 변수란?
		- 박스 int, char, double 이 3가지가 많이 저장됨
		- 박스 규칙
			1. 값을 넣기전 박스 이름을 지어주어야한다 int abc;
			2. 그후 값을 넣는다
	- 디버깅모드에서 변수가 생기는걸 볼수가 있다
	- cout로 변수를 출력하면 변수의 값이 출력된다.
- cout를 한줄로 적을수있다
	- cout<< "";
	- cout<< "";
	- -> cout << "" << "";
- int a= 3.2/2; a는 이때 1이 저장된다 
- a= a+1; -> a++;
	- 오른쪽이 먼저 실행되고
	- 저장이 그다음
- cout<< b++;
	- 이렇게 합쳐서 쓰지 말기 
	- cout<<b;
	- b++; 이렇게하기
- 내가 틀린것
	- cout << "\n"+ 정수형변수 가 작동할거라고 생각함
	- c++에서 문자열과 정수형은 덧셈이 불가능하다
	- (자바는 다른타입의 데이터 결합시 다른타입을 문자열로 자동변환해줌)
	- 한 줄에 한가지 역할만 하도록 구현하는게 한 줄의 목적이 명확합니다.코드 작성자의 의도가 명확하게 코딩해야합니다

- 컴공지식
	- 개천재 폰노이만의 아키택처
		- 저장장치에서 해독되서 cpu로 전달되는데 너무 속도가 차이나서 cpu가 노는 시간이 많아지니까 메모리를 둬야한다고 말함
		- cpu(반도체)-메모리(반도체)-저장장치
			- 저장장치-> 메모리 : 로딩
				- 그런데 메모리에서-> cpu 가는데 속도 차이나 cpu 또 놈
				- 그래서 cpu 내부에 메모리를 또 두고 덩어리로 전달==>캐시 메모리
				- DRAM(메모리) -> SRAM(캐시메모리)
	- cpu 시장
		- pc용 cpu: intel vs amd /설계, 마케팅,,,등등
		- 모바일용 cpu: arm(설계 독점),퀄컴,미드램(조립)
		- pc와 모바일 cpu기술의 차이(cpu회사인 인텔이 모바일cpu를 접수못한이유: 밥줄의 차이)
			- pc는 밥줄이 전봇대 전기라 최대한 가져올수있는 전기를 가져와 빨리 돌림 그래서 너무 발열발생해 선풍기 있음
			- 모바일은 밥줄이 배터리라 최대한 전기를 끌어오면 방전됨 그러므로 최대한 적게 쓰면서 돌려야함(삼성,애플)
	- 메모리시장
		- 1인자: 삼성
		- 2인자: sk
		- 3등: 미국
	- 저장장치
		- ssd: 삼성 
		- hdd: 미국
	- 그래픽카드
		- 앤비디아(arm 회사 인수)

- Shft+ space vm에서의 한영변환
- ctrl+ c/v vm에서의 복붙


2일차
- 변수 
	- 과정
		- 소스코드를 짠다
		- 빌드를 한다 (ctrl+f5)
			- 0과 1로 컴퓨터가 알아들을 수있는 명령어가 된다
		- (과거) cpu가 저장치에 있는 한줄을 가져가고 실행한다
			- cpu는 반도체라 속도가 매우 빠르다(전기의 속도)
			- 저장자치는 디스크라 모터의 속도이다
			- 그 속도의 차이로 cpu는 논다
		- (폰노이만 구조) 메모리의 등장
			- 우리가 실행하면 0과 1이 통으로 메모리에 옮겨지고(로드/ 로딩)
			- 메모리에서 cpu로 명령어를 보낸다
			- 메모리 제일 잘 만드는 나라 1등 삼성 2등 sk~~ 3등 미국
	- 입력
		- 변수를 만들어
			- 이때  쓰레기값 저장되어있어 초기화 시켜줘야 사용할수있음
			- c++에서는 컴파일은 성공했지만, 객체 파일을 연결(link)하는 과정에서 문제가 발생  그래서 c++에서는 지역변수는 반드시 초기화하고 사용해야함
			- 자바에서는 컴파일조차 안됨
		- 실행중인 프로그램에 값을 변수에 집어넣어
			- cout << x 
				- x를 출력(out)
				- <-데이터의 흐름
			- cin>> x
				- x에 입력(in)
				- 데이터의 흐름 ->
				- 두개 이상 입력시엔 cin>>x>>y;
					- cin>>x, y가아니다
	- 변수 선언은 컴파일 단계에 할당됨(코드에서 실행 이전에도 존재하게 됨)
- 조건문
	- if 
		참일때만 진입한다
		- 하나의 비교만을 한다.If(1<=x<=5) 불가
			- 파이썬은 연속비교를 자동으로 분리해 두개의 비교연산으로 처리하고 두 조건이 모두 참일때 참을 반환
			- 자바와 c++은 왼쪽부터 순차적으로 평가
				- 첫번째 1<=의 결과인 논리값을 정수로 변환한값(1 또는 0)와 <=5를 평가(항상참)
- 반복문
	1. i 재사용위해서 for 
		- int i=0; (변수를 처음에 만든다)
		- for(i=0; i<5; i++){
		}
	2. for문안에서 i 선언
- 언어 소개
	- c
	- c++ ->java
	- c++ ->c#
	- python
- 언어 설명
	- c
		- if, for , 변수, 배열, 함수 
	- c++, java, c#
		- if, for , 변수, 배열, 함수, 클래스
	- 그래서 언어 각각 모두 정복하자는 개념이 아니다. 언어를 잘하는게 아니라 코딩만 잘하면 된다.
	- 클래스 
		- 클래스 이전에는 함수단위로 코딩했음
			- 함수 단위로 코딩했던 기존코드를 다시쓸려면 수정이 필요
			- 클래스가 그래서 등장
		- 클래스란?
			- 관련있는 함수들을 포함하는 그룹
			- 클래스를 복붙하면 그대로 사용가능
			- 클래스의 등장으로 클래스 단위로 설계시작(객체 지향설계방식)
- 분야 소개
	- 자신의 전문분야 결정시키는 법 -> 탈락시키기
		- 게임: 게임 개좋아함
		- 정보보안: 해커 멋있으면..?
		- 임베비드: 삼성,sk 들어가고싶다, 전자제품, 기계
		- app: 누구나 쓸수있는, 사람이 아닌 자동으로 작동되는 프로그램
		- web: 누구나 쓸수있는 웹
아래가 제가 지피티써보고 이해한건데 이게 맞을까요? 

질문 1 : 변수를 선언하고 초기화하지 않고 출력할때 빌드가 안되는 현상의 이유는 아래와 같나요?
	- c++에서는 컴파일은 성공했지만, 객체 파일을 연결(link)하는 과정에서 문제가 발생  그래서 c++에서는 지역변수는 반드시 초기화하고 사용해야함
	- 자바에서는 컴파일조차 안됨

질문 2 : f10 눌렀을때 변수 선언하는 코드에 다다르기 전에도 변수가 존재하는 것처럼 보이는데 
	컴파일 단계에서 한번 흩을때 변수 선언코드는 실행됨 그래서 이미 메모리가 할당되어 존재하는것 

질문 3: If(1<=x<=5){}이 항상 참이 나오는 이유
	 자바와 c++은 순차적으로 왼쪽부터 판별하는데,
	 1<=x의 논리의 결과는 참이거나 거짓이다
	 그런데 그 논리의 결과(0또는 1)<=5는 항상 참이므로
	 결과는 항상 참이 된다 그래서 분리해서 조건문을 만들어야한다.
질문 4: 왜 for문 밖에 변수를 선언하고 그걸 사용하지 그냥 For(여기 안에 선언하고 사용하면 되자나) ()안에서는 선언이 c언어는 불가능한가?

- 4개의 수를 비교할때
```c++

#include <iostream>
using namespace std;

  

int main() {

int b1, b2, b3, b4;

cin >> b1 >> b2 >> b3 >> b4;

  

if (b1 >= b2) {

if (b1 >= b3) {

if (b1 >= b4) {

cout << "b1이 가장 크다";

}

}

}

  

  

return 0;

}
```


3일차
- 인터넷
	- 개인을 일일히 모두 연결해 통신하는게 아니라
	- 공유기와 개인을 연결해 공유기를 중심으뢰 정보가 왔다갔다하게 그리고 공유기를 늘려가는 방식으로 확장
- 인터넷 문제점 1
	- 컴퓨터 A의 공유폴더안의 문서를 사용할때 집갈려고 A컴퓨터를 끄면 다른 컴퓨터에서 그 문서를 사용 불가
	- 그래서 공용 컴퓨터를 하나 만들어서 공용컴퓨터에 문서에 저장하고 누구나 접속할수있게 24시간 켜둔다
	- 이 공용컴퓨터를 서버라고 한다.
	- 그리고 개개인의 컴퓨터에는 식별번호가 있는데 이걸 Ip라고 한다
- 인터넷 문제점2
	- 미국에서 한글문서는 안써서 한글문서를 볼수가 없음
	- 문서프로그램이 통일이 안됨
	- 전세계가 공통으로 사용하는 문서=> html
	- html의 문서를 읽어내는 프로그램=> 웹브라우저
		- 웹브라우저를 킨다
		- 서버에 고유번호(ip주소)를 입력한다
		- -> 문서 열람가능
			- 233.130.195.200
			- 네이버 서버 안에 있는 Html 문서(www.naver.com)
- 문서가 심심하다
	- 웹문서 안에다가 If, for 함수를 적용(자바 스크립트)
		- 그래서 웹 개발자가 생겼다
		- 단지 정보공유하는 문서가 아니라 게임도 할수있다
	- 접속하는 사람이 ip주소 입력시 서버가 소스코드를 주고,  접속하는 컴퓨터에서 빌드해 완성본을 보여줌
	- 이때 접속하는 컴퓨터를 클랑리언트라고 한다
- ip주소 외우기 어렵다
	- 중간에 dns라는 서버를 두고
	- naver.com== 233.130.195.200 이다고 저장
- 인터넷 == 웹문서 이렇게 국한된건 아니다
	- 인터넷하면 웹문서를 본다가 통상적이지만
	- 게임, 영상 시청도 가능


- trace는 문법적 오류가 없는 상태에서 해야한다
- for문
	- for(1, 2, 4){
		3
		}
	- 1번-> 2-> 3 > 4->2->3>4->2가 거짓이 될때까지 반복
	- 그러니까 x는 2가 거짓인 상태에서 종료
	- N번 반복하고 싶다
		- x=0; x< n; x++ 이렇게 하면 된다
	- a부터 b까지 출력하고 싶다
		- x=a; x<=b; x++
	- a부터 b까지 출력(내림)
		- x=b; x>=a; x--
	- 내가 구현 못한것(1,7,13,19..출력 (문제 잘못이해))
```
		for (int i = 0; i < 31;i+=6) {
		
		cout<<i<<" ";
		
		}	
```
- 정리
		1. **N번 반복**:
		• x < n: n번 반복하려면 마지막 인덱스는 n-1이므로, “작다(x < n)“를 사용.
		
		• 반복 횟수는 n번.
		
		2. **a부터 b까지**:
		
		• x <= b: b까지 포함하려면, “작거나 같다(x <= b)“를 사용.
		
		• 출력 범위는 a부터 b까지


4일차

- 운영체제(os)
	- 개발자는 앱을 만드는 사람이 많다
		웹의 수준이 높아서 웹앱이라고 부르기도 한다
	- 어플리케이션은 os안에서 돌아가는 얘들
		- os 없으면 안돌아감
		- 웹은 브라우저 없으면 안돌아감
	- 물리적인 하드웨어를 동작시키는것: os
		- windows
			- 윈도우 빼고 리눅스 생태계임
			- 일반사용자가 많이 씀
		- ios
			- unix가 바뀐게 ios
		- android
			- Linux가 바뀐게 android
		- Linux 
			- unix가 바뀐게 Linux
			- 화면이 나오는 전자제품(tv)
			- c언어로 만든 운영체제
			- 서버관련 개발자(웹)
	- 카레이서가 차의 구조를 알듯이 os를 알아야한다
		- os(프로그램)
			- 커널: os의 핵심소스코드
				- 리눅스는 os전체가 아니라 커널이다.
					- 리눅스를 가지고 만든 배포판: 우분투, 안드로이드
			- 기타등등
	- 운영체제를 다루는 방식
		1. GUI (그래픽기반)
			- 편함
			- 단점  
				- 과도한 선택 유도
				- 비효율적인 상호작용
				- 업데이트시 새로 익혀야함
		2. CLI (글자기반)
			- 명령어만 익혀두면 정말 편함
			- 큰 변화가 없음
			- 윈도우: 홈버튼+R누르고 cmd 엔터 누르면 들어가짐
			- 리눅스: 우분투(리눅스의 배포판)
	- 운영체제가 어떻게 하드웨어를 다루는지 공부 ㄱㄱ
- 배열
	- 변수를 여러개 한번에 만들때 사용
	- int 배열이름[변수개수]
		- 변수이름은 배열이름[변수번호]
		- 마지막 칸의 변수번호는: 변수개수-1
	- 초기화
		- 1. 일일히 값을 넣기
		- 2. 생성할때만 가능한 초기화
			- int 배열이름[변수개수]={배열 요소, , ...}
			- 생성된후에 이런식으로 배열요소를 넣을순 없다
			- int arr[6]= {0}; 하면 모든수가 0으로 초기화됨
				- 0이 아닌 다른수를 넣으면 첫번째 배열요소만 그 수로 초기화되고 나머진 0
				- int arr[6]={} 이렇게 해도 모든수가 0 으로 초기화 되는걸 발견함
- 하드코딩
	- cin 입력받아서 넣는게 아니고, 값을 소스코드에 적어두는것
		- ex) int v[6]={1,3,5,6,2,6};
- 저장장치 개발 썰
	- 검증, 개발이 5대 5비율로 인력임
	- 검증인력에서 개발인력 블랙리스트(농담)있음 개발인력 취조미팅하면서 왜 나는 그 버그를 방치했는가.. 설명해야함


- 5일차
	- 빌게이츠와 스티브잡스
		- hp, IBM이 미니 컴퓨터 제작하던 시절 워즈니악이랑 퍼스널 컴퓨터 pc사업을 시작한 스티브잡스
		- 스티브잡스가 대박이 나자 스티븐잡스의 컴퓨터를 거절했던 HP, IBM도 pc 사업을 시작
		- IBM 많은 하청업체 가짐 그래서 IBM이 정한 규격이 현대의 조립식 컴퓨터 규격이 됨(IBM계열 컴퓨터라고 부르기도 함)
		- 하드웨어는 준비됐는데 os가 없어서 이걸 산다고 신문에 공고~
		- 빌게이츠 이때 등장해서 dos라는 회사의 os꺼를 납부
		- 현재 우리가 살수있는 컴퓨터는 2가지 규격임
			- IBM규격(조립식 컴퓨터)
			- APPLE규격
		- 빌게이츠가 스티브잡스꺼 베껴 윈도우 3.0 대박
		- 빌게이츠가 많은 중소기업 죽이는 사업 많이함 (a기능 중소기업 a+b기능가진 제품 출시)\
		
	- 함수: 나만의 명령어를 만드는것
		- 반환 이름(아무것도 없을시 void로 침)
		- 명령어 사용하는걸 호출이라고 한다
		- c언어는 위에서 아래로 읽어서 함수선언이 위에 존재해야 호출할수있다
```c++
			void bts(){
			abc();// 오잉 abc를 읽은적이 없는데? -> 에러!
			}
			void abc(){
			}
			
```

```c++
			void abc();
			void bts(){
			abc();// abc 선언했었지-> 통과
			}
			void abc(){
			}
			
```
- 모든 프로그램은 main에서 시작하고 main에서 끝난다.
	- 변수
		- int
		- char
			- 한 글자
			- ' ' 를 사용함
				- b=a 일때 변수를 넣는건지 문자를 넣는건지 헷갈림
	- 전역변수
		- 지역변수: 함수안에서 선언시 그 함수안에서만 사용가능
			- main안에서 선언
			- 수동초기화
			- for문의 i는 전역하면 안됨.
		- 전역변수: 모든곳에서 사용가능
			- main밖에서 선언
			- 자동 초기화
- 생각못했던 코드
	- 0번 칸부터 시작하여 입력 받은 숫자만큼 배열을 건너 뛴 값을 출력 하고자 합니다.
```c++
for (x = 0; x < 11; x += input)  { 
cout << arr[x] << " "; 
}

```


6일차
- 전자과와 컴공의 차이
	- 전자과는 하드웨어부터-> os까지 만드는쪽
	- 컴공: 만들어진 os 위에서 만드는 어플리케이션을 만드는 쪽
- Low level, High level
	- low: 뿌리가 되는 os 
		- c언어 Only
	- high: os 위의 어플케이션을 만드는 high레벨
		- c,c++,자바,...등등
		- 
- 지난시간 이야기
	- 폰노이만 구조
		- 저장장치
			- 저장장치에서 코드를 빌드하면 0과 1이 되고 실행하면 메모리로 적재 그때의 메모리 영역은 코드영역이라고 함
		- 메모리
			- 변수를 만들면 메모리에 만들어지고 값은 메모리에 저장된다
			- 메모리 고유번호: 메모리주소
				- &변수 로 메모리 주소를 알아낼수 있음 이때의 &를 엠퍼센드라고 함
				- f10 누르고 조사식으로 &변수 등록하면 메모리번호 {저장된값} 이렇게 볼수있음
			- int는 4byte로 32개의 방(비트)을 사용하기로 약속되어 있다.
				- 변수의 주소는 첫번째 방의 주소이다
			- char는 1byte로 8비트이다
				- 1비트는 부호로 사용 그럼 7비트 256의 수를 표현 가능한데 부호있는수이므로 -128~127
				- '15'는 불가
					- 이건 문자 2개
				- Int나 char 나 숫자만 저장함 걍 사이즈 차이 컴퓨터는 숫자만 저장가능-> 변환표를 둔다(아스키코드)
					- 숫자 0이 아닌 문자 0은 아스키 코드 48번
					- 즉 프로그래밍에서는 숫자0과 문자0은 별개다.
					- cout는 출력할때 타입을 본다
						- char네? 숫자->문자로 변환 출력
						- int -> 숫자출력
						- 그냥 char+숫자-> char로 변환되어 저장
						- cout에서 char+숫자-> 더하면서 cout이 숫자로 착각해 타입을 숫자로 출력
						- 그래서 타입을 변경하는것: 캐스팅
							- (char)를 앞에 붙인다
						- '숫자'-'0'== 숫자
							- 아스키코드인걸 아스키코드 시작 번호를 뺌으로서 숫자를 구함 
							 [TIP] char 변수에 글자를 저장하면 글자를 저장한 것처럼
							보이지만 실제로는 숫자로 저장 됩니다.
							따라서 이러한 코드가 가능합니다.
							char one = 'A';
							char two = 65;
							컴퓨터 내부에는 두 코드 모두 숫자로 저장 되어있습니다.
							대신 출력하면 char 변수이기 때문에 문자로 출력 됩니다.
							
					- cin 입력할때 타입을 본다
						- char타입에 숫자 3 cin 입력-> 문자 3 즉 '3'-> 51이 저장됨
					- char a; a에 1저장하면 숫자 1의 아스키 코드 1이 저장
			- 근데 아스키 코드는 한국 글자가 없다 그래서 다른나라에서하면 글자가 깨진다.
				- 그래서 각국의 코드를 만들어 합친 표
				- 유니코드 등장
				- 조사식에 '문자' 등록하면 아스키코드 보인다.
					- 근데 변수>=65보다 변수>= 'A'이게 더 깔끔한 코드니 아스키코드를 알 필요가 없다.
		- cpu
			- 더빨리 실행하기 위해 cpu 내부에 메모리=> 캐시메모리
			

```c++
    for (char i = 'A';i <= 'Z';i++) {

        cout << i << " ";

}

    for (int i = 'A'; i <= 'Z';i++) {

        cout << (char)i << " ";

    }
```

```c++
	arr[i]=t;
	t++;

//이렇게 한줄로 바꿀수 있다
	arr[i]=t++;

```

- for문
	- i,j  쓰면 ||이랑 함께 헷갈림
	- 그래서 가로는 x 세로는 y 사용하기


7일차
- 개발 분야
	- 임베디드 분야
		- 소프트웨어 분야
			- 운영체제 동작을 c로 코딩
			- 아드웨어(체험용)
			- 오렌지보드 지니어스키트(10만원 하드웨어,소프트웨어다 들어있음)
			- 펌웨어 임베디드(작은 임베비드)
			- itos(기존 소프트웨어 수정해 새로)
			- 장점: 한번익히면 오래 써먹음
			- 단점: 노잼
		- 하드웨어 분야
- else if 사용하는경우
	- 순서가 중요하다
	- n>3 ,n>5, n>10 순으로 else if 하는경우
		- N>10은 실행이 안됨
		- 그래서 범위를 세부적으로 설정하거나, n>10이 제일 먼저 오게 순서를 수정.
- 탐색하다: 하나씩 요소를 살펴보다
- 2차원배열
	- for문에 무조건 Y가 먼저다. 앞칸이 세로축임
		- arr \[y] \[x]
	- 초기화 방법
		int arr\[3]\[2]= { {1,2},{5,7},{15,20} };

8일차

- api
	-  어떤기능을 쓰기위한 서비스(함수)들을 개발자들에게 제공
	- 증권사api
		- 증권사에서 개발자가 자동주식 프로그램 만들때 쓸수있도록 증권에서 만든 api(함수) 제공
		- 이렇게 주식매매
- win32api->windows api
	- window 운영체제의 있는 모든 기능들을 갔다쓰라고 만든 api
	- 윈도우 앱 개발자들은 windows api 가지고 개발함
	- 그래서 윈도우앱은 리녹스앱에서 실행x
	- api는 공식홈페이지에서 찾아쓰는게 대부분 외우지x
- \#include <windows.h>
	- win32api 함수들을 사용하기 위해서 써야함
- while(참일때 계속 반복하겠다)
	- for보다 불명확해서 for문보다 적게씀
	- 다만 무한히 반복할때 while
	- 쉽게 쓰는법
		시작값(초기화)
		while(중간값(조건)){
		증감값
		}

- 다차원 배열도 **메모리에서는 1차원 배열처럼 저장**되기 때문에, **중괄호 없이 한 줄로 초기화**해도 가능합니다.  int arr\[3]\[4] = { 1,3,4,1,3,4,6,1,1,1,1,1}; 가능

- 0 이외의 수는 참으로 인식함
	-1 도 참
- ctrl+ c는 콘솔창 멈춤


- 9일차
	- c언어 c++차이
```
scanf("%d", &n);
cin>>n;

printf("%d", n);
cout<<n;
```
- 9일차
	- 빌드 후 실행: ctrl+f5
	- 디버그모드(슬로우 모드로) trace 시작하면서 step over (한줄씩 over로 실행): f10
	- 디버그모드 trace하면서 step into( 한줄씩 함수안을 들어가며 실행) : f11
	- 디버그모드 끄기 :  shift +f10
	- 디버그모드에서 원하는 부분만 살펴보고 싶다!
		- 중단점 설정/취소: 라인클릭후 f9 
		- 중단점까지 실행: f5
	- 구조체
		- 타입은 데이터의 종류이다.
		- struct 구조체이름
			{
			int a;
			int b;
			};
	- call by value
		- 함수 호출하면서 데이터 보냄
	- 함수 선언시 주의점
		- 매걔변수에 Int a,b이런식으로 선언 금지
			- 변수 선언에는 , 가 같은 자료형을 공유하지만 함수 매걔변수는 , 함수매걔변수에서는 각각 독립적으로 자료형을 가져야함
		- 매걔변수를 재선언 하지말자
			- 이미 할당된 메모리와 충돌
	- 배열
		배열에  한꺼번에 숫자를 넣는 것은 배열 만들때만가능합니다.
		int vect[5] = { 1, 2, 3, 4 };// 가능
		vect[5] = { 1, 2, 3, 4};// Runtime Error
		배열을 만들고 난 뒤에는숫자를 하나씩 넣어줘야 합니다.

  
10일차
- 라이브러리: 남들이 가져가라고 만든 소스코드 (iostream)
	- 가져다 쓰는 방법 \#include
		- header파일+ 소스코드 포함
		- header파일+ 소스코드 비공개
			- header파일로 함수 호출힐수있게 함
	- \#include <c++ 공식라이브러리>
	- \#include "내가 만든라이브러리"
	- 헤더파일은 빌드 안하고 cpp코드만 빌드한다.
	- \#include는 복붙이다
		- \#include "header.h"이러면
		- header.h에 써있는 코드가 그대로 그자리에 복붙되는 거임
		- 즉 함수선언을 맨위에 해버려 빌드가 가능하게 함
- 함수 선언만 위에하고 아래에 실행문쓰기 가능
- 오픈소스가 다 오픈소스가 아니다.
	- 라이센스가 있는경우 고치면 법으로 걸림
	- 가져다 쓰는순간 소스코드 공개해야해 이런 것도 있음.. 잘 살펴보기
  
- ctrl f10: 한번에 결과를 볼때, 뛰어넘을때
- f5 f9 :여러번 검토해야할때 여기가 의심지역이닷!
- 파이썬 왜씀?
	- 파이썬-> 쉽다? 문법이 간결하다 
		- 쉽게, 세부적인 기능 뺀 간단히 쓸수있는 라이브러리 (전문가로 제작된 c++라이브러리랑 다름)
		- 설치후 import하면 쉽게 쓸수있다
	- 비전공자 교육용,데이터 사이언스, 자동차 스크립트
- 내가 짠코드 테스트 많이하기. 조금짜고 테스트하기 다짜고 실행하지 말고

- 리턴받을때 변수 만들어 받아준다(함수 호출 자리에 리턴값이 대체한다.)
	- 그래서 요게 된다 cout<< abc()
- 리턴은 값을 되돌려줄뿐만아니라 함수를 종료한다 도 있다
	- 그래서 void 함수에서 함수 종료할때 그냥 return;   함
- break;는 함수 한개 나가는거
	- 2중 for문이면 한개 나가기
		y랑 x가 0~4하는 이중for문인데
		y가 1이고 x가 2일때 break하는경우
		나가버려 1,3일때는 없고 y가 2,x가 0인 경우부터 계속 


11일차
- 어플리케이션 : 운영체제안에서 동작하는 프로그램
	- 윈도즈 앱 개발자
		- 마이크로소프트(c#만듬) 
		- c#이 안정적
	- 안드로이드 앱 개발자
		- 구글
		- 자바(오라클)이 구글에게 소송해서 ->코틀린으로 공식언어로 바꿈
	- ios 앱 개발자
		- 애플(스위프트)
	- 운영체제가 지원해주는 함수가 달라(win32 api)->통합 api(큐티, 자바링) 그러나 성능과 기능이 떨어짐
		- 전문적인 앱만들때는 통합 사용 x 돈많이벌려면 3분야중 하나 정해서 ㄱㄱ
- 웹어플리케이션: 웹 안에서 동작하는 프로그램
- 앱어플리케이션은 풀스택(프론트, 백엔드 모두)서버개발 할줄 알아야함

- 포인터
	- 모든 변수들은 메모리에 만들어진다
	- 그 물리적인 메모리의 주소는 16진수이고 주소는 엠퍼센드로 알수있다 &
	- 포인터란? 변수다 메모리가 있는, 메모리 주소를 저장하는 변수이다
		- 비주얼스튜디오 조사식에서 주소 {?} 이때 ?는 저장한 주소가 저장한 값을 서비스로 보여준것 메모리주소만 저장함.
	- 포인터가 변수 a의 주소를 저장하는것을 'a를 가리킨다' 라고 표현한다
	- \*a 란 변수 a가 가리킨 변수가 저장한 값을 뜻한다
		- 그래서 Int \* a=b; 일때 \*a= 50; 이라면 b의 값은 50이 된다.
	- 즉 가리키고있을때 \*a로 원격제어가 가능하다.
		- cout<<\*a 이것도 가능
		- 즉 별 붙이면 가리킨 변수 자체라고 생각하자
		- int \*a,\*b; \*a=&c; 일때 a=b;는 \*a=&c;와 같다
	- 포인터의 활용
		- return시에 하나만 리턴 가능 이때 여러개 리턴하고 싶을때 포인터 활용
		- 자료구조
	- 주의
		주의: \*p++; 하면 안됩니다. \*p += 1; 이렇게 써 주세요.  
		\*p++ 이것은 \*(p++) 과 같고,  
		이는 p 주소 값에 1을 더한다는 뜻입니다.
- 알고리즘: 문제를 푸는 방법
	- 알고리즘 공부: 천재들의 풀이를 공부
	- 대소 알고리즘: 배열1개 변수1개 배열 탐색하면서 큰경우/작은경우 변수에저장해 알아내기]
	- flag 알고리즘: 변수 1개를 이용해 수 있으면 출력 (한번만)
```c++
//flag 알고리즘
int flag = 0;

for (int i = 0; i < 6; i++) {

if (arr[i] == 9) {

flag= 1;

break;

}

}

if (flag == 0) cout << "x";

else cout << "o";

//count알고리즘

int cnt=0; 
//하고 cnt++ 하고 배열 다 순회후 cnt 출력
```

- 지역 변수의 범위(Scope)는 **변수가 선언된 블록 { } 
- 내부에서만 유효**합니다.즉, **해당 블록{}을 벗어나면 변수는 사라지며 사용할 수 없습니다.**


12일차
- 웹개발자
	- 브라우저상에서 동작하는 어플리케이션을 웹이라 한다
	- 프론트: html 문서에 자바스크립트언어로 소스를 넣고 css로 문서를 꾸민다.
		- 많은사람들이 새로고침 여러번할시 서버에 부담을 가지자
		- 접속시 모든 화명구성을 바로 불러오는게아니라 뼈대만 먼저 로딩
		- 모든 화면구성을 불러오는게 아니라 새로고침될 일부분만 새로고침
		- 유튜브 새로고침하면 뼈대만 보이는거 그게 그 기술임
		- 이기술 라이브러리가 리엑트랑 뷰임
	-  백엔드: 서버(컴퓨터) 웹, Html, dns
		- db 설치
		- sql 명령어
		- rest API( 프론트가 달라고하는 정보)
		- 그리고 서버 엄청 커지면 추가적으로 배워야함
	- 프론트 백엔드 구분하지말고 기본적인건 다하자 서로 소통을 
	- html,css,js->db, sql명령어-> node js, aws-> 뷰,리엑트->리녹스 여기까지 신입이 다 할줄 알아야함
		- 부가적으론 도커나 젠키스나 쿠버네티스 쓰는데 이것보다 위의 기본기를 제대로 하자
		- 트렌드는 금방 바뀐다.
	- 모니터링, 로그관리,서버분산, 무중단 배포(도커) 이런것들은 나중에 배우면 됨
- c언어에서 0은 거짓 1이면 참이다
- 문자열
	- char arr\[4]= "ABC"; cha
		- A B C \0 
		- 이때 마지막의 \0은 문자열의 마지막임을 나타내는 널문자라고 한다 이방식으로 선언하면 자동으로 들어간다
		- 사람은 마지막임을 알수있지만 컴퓨터는 배열이 쭉이어져있어 어디가 끝인지 모른다
		- 그래서 한칸 더 여유를 넣어야한다.
	- char arr\[3]={'A','B','C'};
		- 널문자자동으로 안들어가서 3칸이여도 에러안남
		- 타이핑하기 힘들다
		- cout<<arr은 널문자 나올때까지 출력이라는 뜻이라 이떄의 arr은 오류가 난다
			- 걍 마지막에 추가로 \0 넣어주면 arr 해도 쓰레기값전에 출력된다
			- 쓰레기값을 읽을려하면 에러다 
				- int t; if(t== 5){} t== 5 확인하는 과정에서 에러~
			- 문자열 끝에 쓰레기값 print 비주얼코드랑 다르게 gcc는 에러뜬다 그래서 문자열 길이에 맞춰 for문 해야한다
			- cin할시 뒤값은 모두 쓰레기 값으로 채워진다
		- 'A' 와 "A"의 차이
			- 널문자유무
			- 그래서 char a="A"; 불가(널문자가 있어서)
	- char arr\[4]; cin>>arr; cout<<arr;
		- '문자'배열은 배열명으로만으로도 모두 입력/ 출력이 가능하다 arr\[i ]안해도 됨
			- For 문돌린 arr\[i]는 정확히 몇글자만입력해야한다는 선이 정해짐
		- string은 다음에 배우니 걱정 ㄴㄴ
- 알고리즘 
	- 문자열 입력시 몇글자인지 알아내는법
		- 처음 널값의 인덱스가 문자열의 길이이다
		- 처음 널값의 인덱스를 출력하고 break;를해야 이어진 널때문에 그뒤를 출력하지 않는다
	- 문자열 역순 출력
		- 문자열 몇글자인지 알아내고
		- 거기서부터 For문을 돌린다
			- 내풀이: 걍 배열={} 하고 배열 끝길이부터 역순으로돌려 널값아닐때 출력하면 된다
	- 이중배열숫자채우기
		- 자주바뀌는 행이나 열을 안쪽에 둔다고 생각하기
		- 중심 즉 자주 움직이는 방향이 수직이다->y가 안쪽
		- 중심 즉자주 움직이는 방향이 수평이다-> x가 안쪽
		- 방향이 오른쪽이다 :x++ 왼쪽이다 x--
		- 방향이 아래쪽이다: y++ 위쪽이다 y--
- 포인터: 가리키는 변수의 주소 \*포인터: 가리키는 변수의 내용값 
- char\* a= arr; 인이유 arr은 arr\[0]이다 
- char arr\[3]={0} 일때 아스키코드 0번은 Nul이라서 빈칸으로 채워진다.
- vect\[y]\[x] = vect\[y]\[x] % 10;
	-  10이 될때 0으로 초기화

13일차
- 협업도구
	- git : 소스코드 버전 관리도구
		- 공유폴더를 다같이 사용할시 덮어쓰고 난리남
		- 그래서 게시판같은 git에다가 저장
		- 변경사항 목록이 생기고, 덮어쓸때 경고가 나오고 충돌날라인 알려줌
		- 디버깅하기 좋음 (언제부터 오류가 난거지? 이전 목록들을 쭉 테스트해서 오류 시작점을 알게됨)
	- JIRA: 버그 추적 시스템
		- 감정소모없이 버그관련 얘기하고, 할일적고 이런걸로 고과평가함
	- 컴플러언스: 사내블로그
	- ci서버: 깃만 사용할때 다올리고 퇴근했는데 빌드가 안되면 다시 재출근해야하는 상황 막음
		- ci서버가 깃에 소스코드 올릴때 빌드, 테스트해줌
	- 근데 대학생은 개발자 뽕에 협업관리도구에 쓸줄아는거에 빠지는데 소스코드나 열심히..
	- 팀플해야한다? 중고수를 찾고 인원을 최소화
		- 그게아니면 혼자 빡세게 공부
```c++
int* k;
int b = 7;
k = &b;

//이제부터 *k는 7이다
// 이때 * k++은 우선순위때문에 k++이먼저동작함
// *k+=1 로 쓰기
```
- 콜바이 value(한개만 리턴받는 경우)
	- 변수 a를 넣어 호출시 이걸 받는 변수b
	- 이때 함수에서 받은 b수정시 a는 변하지 않는다.

- 콜바이 레퍼런스(여러개를 리턴받아야하는경우)
	- 매걔변수 &a로 호출하는것 그러면 \*t로 받아야함 (일반변수는 주소 못받음)
	- 즉 주소를 보내면 포인터(주소를 저장하는 변수)로 받아야한다.
	- 이때 함수에서 받은\*t는 main의 a라고 보자 (\*t변화시 a가 변화)
		- 호출 양식
		- abc(&a): a에다가 값을 담아주세요
		- abc(b,c,&a): b랑 c의 '값'을 보낼테니 a에다가 값을 담아주세요
			- 변수 b, c를 보내는게 아니라 그 안의 값을 보낸다고 이해하자
			- &a는 변수 a를 보내는거라고 생각하자
	- 배열을 콜바이 레퍼런스 하는법: 걍 &없이 배열의이름을 넣어 보내고, 배열로 받자
		- 배열의 이름== 배열의 첫번째 값의 주소이다.
		- 배열로 받는것처럼 보이지만 c언어는 내부적으로 배열을 포인터로 바꾼다.
			- 즉 void abc(int a\[3]){}; 이고 abc(v); 했을때 a는 포인터이다
			- 그래서 b= &x가 (배열이지 포인터가 아니니까)안되지만 a=&x가 된다 
			- a는 첫번째 값를 가리키는 포인터이기에 \*a=3; 하면 v\[0]이 바뀐다.
			- 포인터를 배열처럼 저장하듯이 사용해도 된다
				- \*(a+0)=> a\[0] 
				- \*(a+1) 두번째 값을 이렇게 표현해도 같다=> a\[1]
				-  \*(a+2)세번째값을 이렇게 표현해도 같다=> a\[2]
		- 포인로 바뀐배열, 포인터가 가리키는 값을 보고싶다면 배열이름, 요소 수 하면 뜬다
	- 이중배열을 콜바이 레퍼런스 하는법: 배열의 이름만 넣어 보내고, 똑같이 배열 선언으로 받자 (이때 배열\[크기]\[크기] 크기는 꼭써줘야함)
		- 받을때 int (\*arr)\[3] 이건데
		- 이차원내부원리는 너무 어려우서 생략
			- 배열을 가리키는 포인터도 있다
			- 나중에 배운다.
- 아차원 배열 선언
	- char vect\[3]\[4] = { "ADF", "QWE", "ZXC" };
	- **두 배열이 완전히 같은지 다른지 알기 위해서는 두 가지 방법이 있습니다.**
	1. Flag를 쓰는 방법
		flag를 써서, 다른 글자가 존재 하는지를 찾으면 됩니다.
		
		다른 글자가 존재한다면 flag를 1 켜고 break
	2. 함수를 이용하는 방법
		함수를 호출하고, 함수 안에서 for문을 돌립니다.
		
		한 글자씩 탐색하는데 만약 다른 글자가 나타나면 즉시 return 0을 합니다.
		
		for문이 끝나면, 다른 글자가 나타나지 않았기 때문에 return 1을 합니다.
	- 구조체 Type을 설계도 작성 "구조체 정의하다" 라고 표현합니다 구조체 변수를 생성하는 것은 "선언하다"


- 14일차
	- 스타트업(중소)
		- 성공할지 안할지 모름 회사가 사라질주있음
	- 중견
	- 대기업
		- 제조,금융,포털 사이트가 돈 많이줌
		- 삼성전자, 현대, sk
		- 포털: 카카오, 네이버
	- 신입개발자가 처음부터 3년간 취업준비하지말고 차라리 경력쌓아라~
	- 배열 조사식
		- 문자배열 끝까지 채울때 "내용"...
		- 한칸만 채우고 나머지 0으로 채울때 0를 끝으로 인식해서 "ㅁ" 한개만 있는것처럼 보인다
	- 이중 배열 초기화
		- int\[4]\[4]={1,2,3,4,5,6,7,8}; 이면 순서대로 채워지고 나머지 8칸은 0으로 채워지지만
		- 만약에 int\[4]\[4]={(1,2},{3,4},{},{7,8}}; 이렇게 하면 1,2,0,0,3,4,0,0,0,0,0,0,7,8,0,0를 채운 결과가 된다
	- 배열초기화
		- 전역변수는 자동초기화
		- main은 전역변수가 아님으로 선언만 한다면 쓰레기 값으로 차있다
		- main에 int arr\[5];를 만들고 cin>>으로 2개값만 입력하면 3번째값은 널문자이고 4,5요소는 쓰레기값 그대로이다.
		- 널은 숫자로 0 이라 == '\0' 이게아니여도 == 0; 이렇게 해도 된다.
	- 배열 돌기=>마지막 한수만 따로저장하고 다 바꿔주고 처음 자리에 그 한수를 저장하면 된다.
		- 마지막값을 tmp에 옮긴다
		- 맨마지막 바로 앞값을 마지막으로 옮긴다
		- 그렇게 서로서로 다 바꿔준다(나오는 빈자리에 옮겨주며 즉 tmp2개 사용하는 느낌으로)
		- 처음자리에 tmp에 저장된 마지막값을 넣어준다
		- 이를 for문으로 구현할수있다
	- 위의 알고리즘은 shift 방식으로 마지막 값을 임시 저장한 후, **모든 값을 한 칸씩 이동 후 첫 자리에 마지막 값을 넣는 방식**
	- 배열을 뒤집는 다른 알고리즘은 단순 Swap 방식**: for문을 활용해 **배열의 처음과 끝을 서로 교환**하는 방식 → O(n/2)
- 변수이름은 값을담는 공간의 별명을 지은건데 한 공간에 별명이 똑같을순없어요 타입이 달라도 변수이름 같으면 안되어요~
- 정렬
	- 선택정렬
		- 하나 선택후 자신보다 크거나/작을때 스왑
		- 그렇게 끝까지스왑하면 정렬이됨

- 15일차
	- 정보보안
		- 문서나 영상보안
		- 관제
		- 모의해킹(합법적 해킹)
			- 웹서버만 외부에 공개되어있어서 웹서버 해킹이 주가 됨
			- 자바 언어로되어있는 회사가 많아 자바..알아야함
		- 정보보안은 연봉이 작다 특히 초봉작음 
		- 사업하긴 좋다.
		- 이직이 쉽다
		- owasp top 10
		- sql injection
			- 웹에서 중요한 정보를 db에 저장하고, sql로 db접근
			- 아이디 admin이나 로그인하고 싶은 아이디쓰고
			- 비번 a'or'a'='a 이거 하면 로그인 됨.. 왜냐면 sql명령어에서 Or 가 만저고 뒤에 항상 참인 문구를 넣어놔서 항상 참이라 제대로된 비번을 넣어뒀다고 판단하게됨..
		- web shell다운로드
			- 게시판에 이미지로 올려서 업로드하고 실행하면 모든 정보 볼수있음
			- 그래서 이미지에는 이미지만 올릴수있게 해야함
		- 게시판글이나 제목에다가 악성 자바스크립트 넣어두면 자바스크립트가 실행되는 버그
	- 구조체
		- struct BBQ{int a,b;}; 로 정의가능
		- 정의 main에서하면 외부함수에서 사용 불가
		- BBQ t1={1,3}; 이러고 BBQ t2=t1; 이렇게 복사가능 근데 BBQ t1= t2+t3 안됨
		- 구조체 값채우고 반환하는 함수를 만들수가 있다.
			- 전역변수로 struct BBQ{Int a,b;}; BBQ bts(BBQ t1){} 정의하고 main에서 bts({3,7}); 이렇게 호출하면 return t1 하면 값이 들어간 BBQ를 반환받을수있다.
	- 이해가 안되면 능숙해질때까지 좀더 쉬운걸 봐라
	- 문자열 여러개 담는법
		- char arr\[문자열 수]\[문자열의 문자수-1];
		- cin>>arr\[1] 이렇게 문장을 다룰수 있음 
		- 초기화안하고 입력할시 널문자 뒤에는 모두 쓰레기값이다 
		- 쓰레기값을 건들자마자 바로 에러뜬다 (비주얼 스튜디오에서는 처리해주는데 다른데에서 x)
			- 그래서 널문자 찾자마자 break하는거임
		- c언어는 "ㅁㄴㅇㄹ" "ㅁㄴㅇㄹㄴㅁㄹ" 사이에 콤마가 없다면 한문장으로 생각한다 
	- 자료구조를 알아야 선택을 할수있다
	-  4자리수 하나씩 뽑아내는 법 a = num / 1000; b = num / 100 % 10; c = num / 10 % 10; d = num % 10;

- 훈련반 준비
	- scanf로는 방향키 누르고 엔터 또 누르고 방향키 누르고 또 누르고 그래서 게임 만들기 힘들다
	- 그래서 키보드를 관리하는 운영체제한테  도움을 요청해야한다
	- 그게 win32api이다 (현재는 windows api)
		- 윈도우 도움을 받은거라 윈도우에서만 돌아간다.
	- 게임은 무한루프 while이다 유저가 게임종료버튼을 누른경우를 제외한 무한루프
	- 방향키 위로가기를 눌렀을때 아래가 참이됨
		- (GetAsyncKeyState(VK_UP) & 0x0001 
		- GetAsyncKeyState(VK_UP): 방향키 아래가 눌렸을때 ctrl/alt/shift...등도 눌렸는지..많은 정보를 비트 이진수를 십진수로 리턴함(이진수 한자리가 무엇에 대한 정보인지 정해져있음)-> &로 필요한 정보만 뽑아냄.
		- 이때 위로올라가는건 y--이다 배열생각해서 헷갈리지 말기
	- Sleep(1) 
		- 0.001초 잠들기
		- 함수이름은 첫글자가 대문자인듯
	- \#include< cstdlib >
		- 애니메이션
		- 콘솔지우는 명령어
			- system("cls")
	- cmd+r :실행창
		- 여기서 cls 치고 엔터누르면 기존기록 다 지워지고 깨끗해짐
		- 그러니까 cls는 커멘드 쉘 명령어다 
	- const :상수
		- 원래 char\[n] 이렇게 선언하는건 안되는데
		- n를 상수로 하면 가능
	- 알파벳은 한칸, 한글과 특수문자는 2칸 

- 훈련반 1일차 
	- 이제부터는 문제를 이해하고 설계한뒤 구현한다
	- 설계란? 계획이다 더 큰 프로그램 만들려고, 버그 낮은 안정성, 탄탄한 구조, 구현력 상승을 위한 계획
	- 방식
		- 코드 없이 계획을 짜기
		- 계획을 구체화하기
			- - 변수이름, 배열이름, 함수이름 짓기
		- 그 계획으로 구체적인 입력값을 계획에 넣어 시뮬레이션 돌리기
	- 문자열 입력받고 맨 마지막 글자랑 중간글자를 찾아내서 이 두개를 바꿔라 그리고 역순으로 출력하라(마지막 글자랑 중간글자를 못찾으면 에러라고 출력하기)
		- 1. 배열 kfc 에다가 입력받고 마지막 글자 last 변수에 넣을까 말까하는데 스왑이니까 이 마지막 인덱스를 변수에 저장해야겠다 인덱스알아낼려면 2. 전체길이를 구해야겠군
		- 인덱스는 길이 -1  그리고 중간글자 mid에는 전체길이/2하면 될까 이걸 직접 테스트 abcde 5글자 나누기 2== 2 맞군
		- 그다음에 4. swap하고
		- 길이-1 부터 5.역순출력하면 되겠네
		- 그다음 3. 에러처리는 맨 처음에 하자
	- 이제 순서 주석처리하고 코드로 구현
		- 입사테스트할때 옆에서 키보드 소리가 엄청남->설계안하고 코딩하게됨 보자마자 코딩하는사람 다 탈락(코테는 몰라도 대회에선 탈락임) 설계를 꿋꿋이 하자
	- 뒤에 널문자있으면 문자열 그냥 출력해도됨 cout<< arr; 가능
	- trace
		- step over: f10
		- 한줄씩 실행하는 기능= Trace
		- debugging : 버그를 죽이는 활동하고있는것을 디버깅이라하고
			- 디버깅을 할때 trace라는 기능으로 디버깅
			- 개발자들은 눈으로 코드흝기, 출력해서하기 보다 trace 기능을 활용한 디버깅을 겁나 잘해야함
				- 그게 속도 개빠름
		- jump: ctrl+f10 (커서위치 줄 전까지 실행)
		- step into :f11 (함수안까지 실행하는거 보여줌)
	- 설계방식
		- to do(할일 적기)설계
			- 어떤함수가 있으면 편할까 적어두고 설계 다 끝나고 구현하기 (그걸 당장 구현하려하지 말고 이미 완성되어있다고 가정하면서 설계하기)
		- 함수 구현
			- getmax4는 배열에 넣고 for문을 돌리자
			- getmax2는 큰거 리턴이니까 설계 안해도됨
				- 2x4 2차원배열 가로줄의 합의 최대, 세로는 곱의 최대를 구하고 둘중 제일 큰 결과를 구하는 문제
				- 함수에 배열 줄을 넣으면 합 최대를 반환하는 함수 (2개) 곱의 최대를 반환하는 함수(2개) 2개 값을 넣을때 최대를 반환하는 함수(이건 만들필요 없었는데 그냥 만듬)
					- 어떤함수가 있으면 편할까 적어두고 그걸 당장 구현하려하지 말고 이미 완성되어있다고 가정하고 설계 다 끝나고 구현하기 
				- d1에다간 맥스값찾고 d2에다가 맥스값 찾고 그 두개를 2개짜리에다가 넣어서 최대값 반환해 boss1에 저장하자
				- for 4회 맥스 2칸 함수 4회 boss2 갱신시키는 방법으로 
				- boss1 boss2를 비교해 가장 큰것 출력
		- 세부설계하는법
			- to do 설계후 바로 코딩하기 힘들겠다(4중For문같은 경우)싶으면 그부분 계획을 최대한 명확히 설계하기(필요하면 손코딩) 몇부터 몇까지 돌리고, 안의 실행문
		- 시뮬레이션설계 돌리기
		- 그리고 순서대로 개발하면서 기능 하나 완성하면 테스트
			- 즉  세부계획, 시물레이션으로 이미 계획 다세워서 코딩할땐 생각하는게 아니라 그냥 완성된 코드를 입력한다고 생각
	- 훈련반 1숙제할때 
		- 하드코딩아닌 문제 디버깅 할때마다 입력하면서 하지말고 하드코딩 해놨다가 제촐할때 하드코딩 부분 빼기
		- 버그나오면 코드 흝어보기x 기능 하나 완성할때마다 테스트
```c++ 
int isExist(char arr[2][7], char input) {//그냥 Flag변수 추가안하고 1,0 리턴하고 result라는 변수로 받기. 
int x, y; 
for (y = 0; y < 2; y++) { 
	for (x = 0; x < 6; x++) { 
		if (arr[y][x] == input) { 
			return 1; 
			} 
		} 
	} 
return 0; 
}
```
- 훈련반 2일차
	- # 단축키
		- ctrl+d:지금 줄 다음줄에도 복수
		- shift+ delete: 지금줄 삭제 (내 맥북노트북에선 fn+shift+backspace)
		- ctrl+ option+w 눌렀다가 다 떼고 숫자 1 누르기 : 코드창에서 조사식으로 이동 
			- 다시 코드창으로 돌아가기 esc
		- option+방향키: 그 줄 옮기기
	- # f10 vs f9 아니 둘다 이용하자
		- 전체를 디버깅하는게 아니라, 디버깅은 추리이다 점프라는 기능이 문제일때 f9는 점프소스코드 시작지점에 설정(그래서 거기부터 f5 여러번 시작하는 디버깅할 수 있게)
		- 그이후로 f10으로 넘어가거나 ctrl+f10으로 구간 점프를 하거나하면 됨
	- ##### 디버깅할때 여러함수를 호출할떄  '함수호출스택'를 보고 함수를 클릭하면 조사식에서 클릭된 함수의 지역변수 값을 보여줌(main의 i-> abc의 i 다르니까 관측기준은 함수호출스택에서 클릭된 함수)
	- ### 반복문 50번중 48번부터 이상하다 
		- 그럴땐 디버깅코드(아무의미없는데 47번째에 멈추게하는 코드)를 만들고 그 지점부터 중단점설치후 디버깅하면된다
			- if( i == 47){int d=1;} 이런 의미 없는 코드를 넣어준다.
		- 중단점 조건을 설정하는 방법도 있지만 디버깅 코드를 넣어주는 방식이 더 빠르다 (로딩 오래 걸림)
	- ### 지역변수랑 전역변수는 저장되는 메모리가 다르다
		- 빌드할때
			1. 코드 정리작업(각 파일전부 )
			2. 각 파일들 각각 컴파일러 돌려서 0과 1로 번역(프로세싱)
			3. 여러게 파일들을 하나의 Exe파일로 합친다
			- 합치는건 링커인데 링커옵션에다가 지역변수 메모리를 조절할수있는데 기본은 128Kb이다
			- 즉 4b인 Int 변수 100000개정도 밖에 못만듬  즉 10만개 넘는 배열 만들면 스택 오버플로우
		- 즉 십만개 정도다 전역에 선언한다
			- Map\[1000]\[1000] 이상이면 전역으로~
		- 빌드에러란?
			- 위 1,2,3중 하나에서 에러가 남 걍 통합해서 빌드에러라고함
			- 빌드에러 발생시 오류목록보고 찾아내기
			- ##### 빌드 되는데 버그 발생->중단누르고->f5 누르면 오류목록이 친절하게 나옴
			- 컴파일에러
				- 빌드실패
				- trace가 안됨
			- 런타임에러
				- 빌드에 성공했다-> 실행파일이 만들어짐
				- 실행하면 실행도중에 나오는 에러를 런타임 에러라고한다
				- trace 가능
			- 링커에러
				- 합치는 과정에서 에러
	- # 디버깅 하는 노하우
		1. 문제 이해-> 설계-> 설계에 실제입력을 넣어봐 시뮬레이션->구현-> 디버깅
			- 이 시뮬레이션을 해야하는 이유: 설계 검증뿐만아니라 
			- 디버깅할때 왜 이렇게 안나왔지? 흐름 대조비교가 가능 그래서 빨리 찾을수있다
		2. 디버깅이란 추리다
			- 용의자를 좁히자 그리고 f9하고 천천히 trace f10 이렇게 찾아내기
			- 그냥 눈으로 흐름 대충 읽지 말고 정확히 설정하기.
		3. 모든걸 의심하기
			- 작은 변수들이 예상과 다르기 때문에 버그가 난거다 
			- 그냥 흘러가지 말고 조사식에 모든 변수 등록하고 값들을 다 확인해야함
			- 소스코드에 내 시간 훔친 범인이 있다 멍때리면서 trace하지 말고 의심하기
			
```c++
void bts() {

cout << "hi"<<endl;//(여기에 중단점하고 호출스택켜서 변화 예상해보기)
//5 //8 //11 //16
}

void cdd() {

bts();//4 //10 //15

cout << "cdd" << endl;//6 //12 //17

}

void kfc() {

cdd();//3

bts();//7

}

void abc() {

kfc();//2

cdd();//9

cout << "abc"<<endl; //13

}

  

int main() {

abc();//1

cdd(); //14

return 0;

}

```
- 순서(나 이거 틀렸었음 한번 다시 확인할것)
	- abc->kfc->cdd->bts
	- bts가 끝났으니 cdd로 돌아가서 아래코드 실행(출력)
	- cdd가 끝났으니 kfc로 돌아가서 아래코드 실행(bts)
	- bts로가서 실행이 끝났으니 kfc->abc로 돌아가서 abc다음줄 cdd호출, ccd 첫줄 bts실행 
	- bts가 끝났으니 cdd로 돌아가고 cdd 다음줄 출력 cdd끝났으니 .... 너무 복잡해서 헷갈려 소스코드 주석 숫자로 표현함
- 조사식vs 로컬
	- 로컬은 자동으로 지역변수만 등록됨(전역x)
	- 조사식과 로컬만 사용하자 자동은 사용하지 말자!


## 훈련반 3일차
- 함수의 매개변수에서 배열은 몇개짜린지 안써도 된다 어처피 포인터다
	- int count(int arr\[]){} 가능
- ### 라이브러리 이용
	- #### \#Include \<cstring> : c언어의 string 라이브러리
		- ##### strlen() :배열의 길이를 구해줌('\\0'인 인덱스 반환 우리가 여태 연습했던것)
			근데 for(int i=0; i<strlen(arr); i++) 이런식으로 For문안에 넣으면 속도 느림(for문 돌면서 매번 계산해 쓸데없는 연산많아짐)
		- ##### strcmp() : 같으면  0를 리턴함
			우리가 만든 isSame()임
			- 앞에 있는 문자열이 사전순으로 더 크면 1 반환
			- 앞에 있는 문자열이 사전순으로 더 작으면 -1 반환
			- 주로 앞에 느낌표를 붙여 if(!strcmp()) cout<<"참"; 이렇게 사용 
		- ##### strcpy():  뒤에 있는것을 앞으로 복사.
		- ##### strcat():  앞에있는것에 뒤에있는것이 뒤에 붙음.
		- 근데 이거 불편해서 c++에서는 string이라는 클래스가 있다
			- 문자열을 저장하고 str.length하면 길이 출력되고 배열처럼 쓸수있다 가독성이 좋아 이것많이 씀
- 함수이름 지을때 동사+명사
- 자료구조: 수많은 데이터를 쉽고 빠르게 찾기위해서 어떻게 저장할지 선택
	-  DAT(Direct Addressing Table)
		-  값을 다른배열의 인덱스로 쓴다 (숫자4의 개수를 인덱스 4번의 값을 증가시켜 개수를 저장)
		- 매우 빠름(입력받을때마다 새로 검사하는게 아니라 입력받기전에 모든 횟수를 구하고 저장)
		- 그래서 초기세팅으로 횟수 모두 구해놓고 코드짜는 방식
		- 그런데 범위가 커진다면 메모리 낭비가 크다, 음수는 사용 못한다 이걸 극복하기위해선 해시테이블을 사용(심화반2..)
		- 유의사항
			- ##### 0으로 초기화 필수
			- #### flag대신 사용가능!
				- ++로 증가시키는게아니라 =1만 해서 1이면 존재, 아니면 없음!
			- 1부터 65525번까지있을때 이렇게 센스있게 선언->int cnt\[65535 + 1]
				- 몇부터라는 수가 있으면 for문돌릴때 그전의 수는 제외하고 돌리기
			- 문자배열에서 구할때 길이 130개정도 선언하고 for문에서 시작하는 알파벳 아스키 코드부터 돌리면 됨 (65= i; i <=130; i++)
- break vs continue
	- break: 탈출/ continue: 다음 진행할코드를 넘기고 (이번 i번쨰 반복을 넘기고) i+1턴을 실행 
- int train\[] = {3, 7, 6, 4, 2, 9, 1, 7};  초기화까지 한번에 시키면 요소개수 안써도 되는거 이제앎;;;


### 훈련반 4일차
- 패턴찾기
	- 큰배열에 작은배열이 포함되어있는지 찾는알고리즘
	- main에서는 isSame를 큰배열안에 작은배열크기로 몇번 쪼개냐(큰배열을 작은배열로 쪼갠 횟수만큼 돌림) isSame은 쪼개서 전달된 작은배열크기의 큰배열의 인덱스로 작은배열랑 하나씩 비교(작은배열 크기만큼 돌림)	
		- 존재하는지 여부만 알아내는경우  isSame있을때 다를때 0를 리턴
		- 몇개있는지 알아내는 경우 isSame에서 다를때 0를 리턴하고 cnt+=issame(~);이렇게
		
	- 이중배열일경우 Y축을 넘어 찾지 않도록 주의
		- arr\[2]\[4]에서 연속된 3개 찾을때 (1,2), (1,3), (2,1) 이렇게 찾고 정답이라고 안나오게
- c언어에서
	- scanf를 Ms visual studio의 sdl검사로 강제로 막고있음
	- scanf_s를 쓰라며 막는 이유는 scanf는 버퍼오버플러우 해킹 기법에 취약함
	- 현업에는 scanf_s쓰지만 코테 할때는 scanf사용
- c++ 에서
	- strcpy도 버퍼오버플러우 해킹 기법에 취약함
- ### DIRECT 탐색: 기준점을 선택한후 탐색
	- 기준점 기준으로 위 아래 오른쪽 왼쪽의 합을 구해라
	- 총 4개의 If문을 줄일수있다.
```c++
int direct[4][2] = {

-1,0,

1,0,

0,1,

0,-1

};

for(int i=0; i<4; i++){

	int dy = y + direct[i][0];

	int dx = x + direct[i][1];
	
if (dy < 0 || dx < 0 || dy >= 4 || dx >= 5)  continue;

//요 if문을 넣어주면 가장자리여도 에러가 나지 않는다(범위 내에서만 더하게 코딩)
sum += map[dy][dx];
	

}
int directy[5] = { 0,-1,-1,1,1 };
int directx[5] = { 0,-1,1,-1,1 };
//이렇게 두개로 나누어 정의해도 된다
```

```c++
if (arr[y][x]) {

flag=isExist(y, x);

if (flag)break;

}

//이 코드는 아래와 같다
if (map[y][x] == 1 && isStable(y, x) == 0) { flag = 1; break; }

```

```c++
//dat를 출력할때 이렇게 의미있는 인덱스를 지정해서 For문을 돌릴수도 있다.
	//대문자범위에서 출력~
for (int i = 'A'; i <= 'Z'; i++) { if (bucket[i] == 1) { cout << (char)i; } }

```


### 훈련반 5일차
- int \*a=&b 일때
	- a=> b의 주소를 의미하고 (포인터 a가 저장한 값)
	- \*a => b의 '값'을 의미한다 (포인터 a가 저장한 주소를 가진 변수의 값)
- 더블포인터
	- 싱글포인터를 가리키는 포인터
	- Int \*b=c이고 int \*\*a=\&b; 일때
	- a => b의 주소를 의미하고(포인터 a가 저장한값)
	- \*a=> c의 주소을 의미한다(a가 저장한 주소의 변수의 값)
	- \*\*a 하면 c의 값을 의미한다.(a가 저장한 b 주소, b가 저장한건 c주소, c가 저장한 값.)
- 명확하게 기억할 3가지
	- 포인터: 주소를 저장하는 변수
	- 가리킨다: 주소를 저장할때 가리킨다라고 표현 
	- 주소를 가리킬때  \* 을 붙여서 대신 접근이 가능.
	- 어따씀?
		- 링크드리스크
		- 함수콜백할때 여러개 리턴
- 재귀호출
	- for문으로 구하기 힘들건 재귀호출로 구한다
- #### 아래 코드를 디버깅 f11하면서 화살표가 어디가는지 정확히 예측하는 연습하기 이거 틀림
```c++
int a = 0;
void abc(){
if (a == 2) { // 이때 바로 return이라고 같은줄에 써버리면 디버깅 다르게 됨
return;
}
a++; 
abc();

int d = 1;//dummycode 넣어야 호출끝나고 돌아는 모습이 잡힌다는걸 몰랐음 이거 없으면 한번에 호출스택 사라짐
}

int main() { 
abc();

return 0;
}
```
- 포인트
	- a== 2에 걸려 리턴되고 그전에 호출한 곳에서 남은 코드 Int d=1이 실행될때 여전히 스택은 3개임
		- 즉,  자신이 종료되도 스택에는 남아있으며, 자신을 호출한 이전 두번째 스택이 종료된 후에야 스택에서 해제됨
- argument(보내는거) parameter(받는거)
- 레벨
	- 재귀호출할때 한단계 한단계 넘어가는걸 레벨이라고 한다.
- return 0; 사용법
	- Main에 단 한개만 사용하는게 아니라
	- 특정 조건을 만족하지 않고 다음 연산이 필요없어 바로 종료해도 될때 사용하면 좋다
	- 불필요한 연산이 줄어들고, 불필요한 중첩 막음
	- 그러나 가독성, 유지보수, 디버깅이 어렵다. 디버깅시 여러개의 종료지점을 추적해야함 
	- 최적화가 필요할땐 적절히 사용하자
- **gpt say🔹 헷갈리기 쉬운 개념 요약 (언제 +1, -1을 해야 하는지)**
	- ✔ **“범위”와 “개수” 개념을 헷갈리지 말 것!**
		✔ **0-based vs 1-based 차이를 인식할 것!**
		✔ **반복문, 중간값, 원형 순환 등에서 +1 또는 -1이 필요한 경우를 구분할 것!** 🚀**
	- **✅ 1️⃣ 범위 개념 (시작과 끝)**
		
		• **개수를 구할 때는 +1 필요**
		
		```
		개수 = (끝 - 시작) + 1
		```
		
		**예제:** 'A'부터 'Z'까지 개수 → ('Z' - 'A') + 1 = 26
		
	- **✅ 2️⃣ 배열 인덱스 (0부터 시작)**
		
		• **배열 길이 = 마지막 인덱스 +1**
		
		```
		int arr[5];  // 길이는 5지만, 인덱스는 0~4
		```
		
		**반복문 주의**
		
		```
		for (int i = 0; i < 5; i++)  // ✅ (0~4 반복, 올바름)
		for (int i = 1; i <= 5; i++) // 🚨 (1~5 반복, 오류 가능)
		```
		
	- **✅ 3️⃣ mod 연산에서 원형 순환**
		
		• **음수 인덱스 보정 필요 (+ size)**
		
		```
		index = (current_index + shift) % size;
		index = (index + size) % size;  // 음수일 경우 보정
		```
		
	- **✅ 4️⃣ 중간값 구하기 (짝수/홀수 차이)**
		
		• **중앙값 계산 시 짝수 개수일 때 +1 필요할 수도 있음**
		
		```
		int middle = (start + end) / 2; // 짝수 개수일 때 정확한 중간값 고민 필요
		```
		
	- **✅ 5️⃣ 1-indexed vs 0-indexed**
		
		• **1부터 시작 (사람이 세는 방식) vs 0부터 시작 (컴퓨터가 세는 방식)**
		
		```
		for (int i = 1; i <= n; i++)  // ✅ 1-based index
		for (int i = 0; i < n; i++)   // ✅ 0-based index
		```
		
	- **✅ 6️⃣ n번째 vs n개 차이**
		
		• **n번째는 1-based, n개는 0-based**
		
		```
		arr[n-1];  // n번째 요소를 가져오려면 `-1` 필요
		```
		
	- **✅ 7️⃣ >= vs > 범위 비교 차이**
		
		• **“이상”(>=) vs “초과”(>)의 차이**
		
		```
		for (int i = 0; i <= 10; i++)  // ✅ 0~10까지 반복 (포함)
		for (int i = 0; i < 10; i++)   // ✅ 0~9까지 반복 (10 미포함)
		```
		
	- **✅ 8️⃣ ++i vs i++ 차이**
		
		• **전위 증가 (++i) → 먼저 증가 후 연산**
		
		• **후위 증가 (i++) → 연산 후 증가**
		
		```
		int i = 5;
		cout << i++ << endl;  // 🚨 출력: 5 (출력 후 증가)
		cout << ++i << endl;  // ✅ 출력: 7 (증가 후 출력)
		```
		
	- **✅ 9️⃣ sizeof()와 배열 크기 계산**
		
		• **배열 크기 구할 때 sizeof() 활용**
		
		```
		int arr[10];
		cout << sizeof(arr) / sizeof(arr[0]);  // ✅ 배열 개수 (10)
		```
		
	- **✅ 🔟 오프셋 개념 (n번째 위치 vs 실제 인덱스)**
		
		• **포인터 연산 시 주소 vs 값 차이 주의**
		
		```
		int arr[] = {10, 20, 30, 40, 50};
		cout << arr + 2;      // 🚨 주소값 증가 (값 출력 아님)
		cout << *(arr + 2);   // ✅ 30 출력 (배열 요소 접근)
		```
		


### 훈련반 6일차
- 오늘의 목표: 다음의 코드를 이해하기
```c++
	void abc(int lev) {
	for(int i=0; i<2; i++){
		abc(lev + 1);
		}
	}
```
- 즉 다음을 이해하기
```c++
	void abc(int lev) {
	abc(lev + 1);
	abc(lev + 1);
	}
```
- 시범코드
```c++
void abc(int lev) {
if(lev==2)return;
(up)abc(lev+1);
(down)abc(lev+1);
}
//
abc(0) //1
├── (up)abc(1) //2
│   ├── (up)abc(2)  //3 (lev == 2이므로 종료)
│   ├── (down)abc(2) //4 (lev == 2이므로 종료)
│
├── (down)abc(1) //5
    ├── (up)abc(2) //6 (lev == 2이므로 종료)
    ├── (down)abc(2) //7 (lev == 2이므로 종료)	
//결국 이건 이진트리와 같다 루트노드가 main이 아니라 abc(0)이다~

```
- 내가 틀린것 1,2,3
	```c++
	void abc(int lev) {
	if(lev==2)return;
		abc(lev+1);
		cout<<"#"
		abc(lev+1);
		cout<<"#"
	}
	일때 출력될때 과정을 화살표로 이진트리에 표시하는거 틀림 
	```
	```c++
	int cnt;
	void abc(int lev) {
	if(lev==2)return;
	cout<<cnt;
	for(int i=0; i<2; i++){
		cnt++;
		abc(lev + 1);
		cnt--;
		}
	}// 답은 011
	``` 
	
	```c++
	void abc(int lev) {
	if(lev==2)return;
		cout<<lev;
		abc(lev+1);
		cout<<lev;
		abc(lev+1);
		cout<<lev;
	}
	일때 출력될때 과정을 화살표로 이진트리에 표시하는거 틀림 
	그치만 내가만든 호출순서 공부용코드 비교하면서 보면 이해됨
		//첫번째 lev은 위쪽 시작했을때, 두번째는 아래쪽 시작했을때, 세번째는 아래쪽도 끝난 즉 종료될때 
		내가 낸 문제 0은 몇번째마다 출력되는가?
	```
	- 순서도
		```
		abc(0)
		├── cout << 0  (1️⃣)
		│
		├── abc(1)  (2️⃣)
		│   ├── cout << 1  (3️⃣)
		│   │
		│   ├── abc(2)  (4️⃣) → Base case (종료)
		│   │
		│   ├── cout << 1  (5️⃣)
		│   │
		│   ├── abc(2)  (6️⃣) → Base case (종료)
		│   │
		│   ├── cout << 1  (7️⃣)
		│
		├── cout << 0  (8️⃣)
		│
		├── abc(1)  (9️⃣)
		│   ├── cout << 1  (🔟)
		│   │
		│   ├── abc(2)  (1️⃣1️⃣) → Base case (종료)
		│   │
		│   ├── cout << 1  (1️⃣2️⃣)
		│   │
		│   ├── abc(2)  (1️⃣3️⃣) → Base case (종료)
		│   │
		│   ├── cout << 1  (1️⃣4️⃣)
		│
		├── cout << 0  (1️⃣5️⃣)
		
		```
- 내가 만든 호출 순서 공부용 코드1,2
	```c++
	#include <iostream>
	using namespace std;
	
	  
	
	void abc(int lev) {
	
	cout <<lev <<"start ";
	
	if (lev == 2) {
	
	cout << "&return\n";
	
	return;
	
	}
	
	cout <<"up";
	
	abc(lev + 1);
	
	cout <<"down";
	
	abc(lev + 1);

	cout << lev << "end\n";
	
	}
	
	  
	
	int main() {
	
	cout << "mainstart\n";
	
	abc(0);
	
	cout << "mainend";
	
	return 0;
	
	}
	```
	```c++
	#include <iostream>
	
	#include <cstring>
	
	using namespace std;
	
	  
	
	void abc(int lev) {
	
	cout << "abc[" << lev << "]start ";
	
	if (lev == 2) {
	
	cout << "&return\n";
	
	return;
	
	}
	
	for (int i = 0; i < 2; i++) {
	
	cout << "lev" << lev << "의" << i << "번째재귀 ";
	
	abc(lev + 1);
	
	cout << "[lev:" << lev << "<-] ";
	
	}
	
	cout << "abc[" << lev << "]end\n";
	
	}
	
	  
	
	int main() {
	
	cout << "mainstart\n";
	
	abc(0);
	
	cout << "mainend";
	
	return 0;
	
	}
	```

- #### 4번 재귀호출일때 3번째 재귀호출의 2번째 재귀호출의 직전에 디버그하는 방법?
	- ##### **호출부분에 중단점걸고 F5로 실행 → F10으로 브랜치 이동 → F11으로 내부 진입 후 재귀 호출 직전에서 멈추기**
	- F10누르다가  **i == 2일 때 F11로 진입 후, i == 1일 때 다시 F11로 진입** (0부터시작이므로 1씩 빼서 들어가기) 다른조건에는 f10눌러서 그냥 넘겨끝내기  
	- 요상한내가만든 아이디어
		```
		#include <iostream>
		
		using namespace std;
		
		  
		
		int branch;
		
		  
		
		void abc(int lev) {
		
		  
		
		cout << "abc[" << lev << "]start ";
		
		  
		
		if (lev == 2) {
		
		  
		
		cout << "&return\n";
		
		  
		
		return;
		
		  
		
		}
		
		for (int i = 0; i < 4; i++) {
		
		if (lev == 0) { branch++; }
		
		  
		
		cout <<branch<< "의lev" << lev << "-" << i << "번째재귀 ";
		
		if (branch == 2 && i == 1) {
		
		cout << "#";
		
		}
		
		abc(lev + 1);
		
		  
		
		cout << "[lev:" << lev << "<-] ";
		
		  
		
		}
		
		cout << "abc[" << lev << "]end\n";
		
		  
		
		}
		
		  
		
		  
		
		  
		
		int main() {
		
		  
		
		cout << "mainstart\n";
		
		  
		
		abc(0);
		
		  
		
		cout << "mainend";
		
		  
		
		return 0;
		
		  
		
		}
		```

- ##### 위의 코드기준으로 호출스택에서 Lev 깊이일때for문의 i가 몇번째인지를 확인해 재검증 가능
- ##### 혹은 path배열을 만들어 현재위치를 알아낼수있다.
	- 먼저 전역배열인 Path\[level개수]를 만든다
		- 값을 이곳에 집어넣을건데 1를 왼쪽을 뜻하고 2는 오른쪽을 뜻한다
		- 만약에 Path\[2]\[0] 이면 두번째에 들어간 상태를 말한다 Path\[2]\[1] 이면 두번쨰에서 첫번쨰에 들어간 상태 
	- 재귀 직전에 배열에 적어주고 호출을 한다
	- 재귀에서 돌아오자마자 지운다. 
	- 이때 Path배열을 문자열로 만들고 '1'+i 하면 출력할때 cout<<path로 한번에 출력가능
	```c++
		//3.Path, name배열
		void run(int lev){
		//1. 바닥조건
		if(lev==2){
			return;
		}
		//2.브랜치 조건
		for(int i=0; i<2; i++){
			path[lev]=i+1;	//현재 레벨에서 여기를 택했어, 난 이제 여기로 갈꺼야 내용을 기록 
			//이떄 1를더해주는이유는 넣어야하는 숫자가 1(왼쪽)부터 시작인데 i는 0부터 시작이라
			run(lev+1);//실제로 이동
			path[lev]=0;//path배열에 나는 이제 돌아갈께 기록한것을 지운다
			}
		}
	
	```
	```c++
	abc(0)   ⮑ path: [0]
	├── (up) abc(1)   ⮑ path: [0, 1]
	│   ├── (up) abc(2)   ⮑ path: [0, 1, 2]  (lev == 2 → 종료)
	│   ├── (down) abc(2)   ⮑ path: [0, 1, 2]  (lev == 2 → 종료)
	│
	├── (down) abc(1)   ⮑ path: [0, 1]
	    ├── (up) abc(2)   ⮑ path: [0, 1, 2]  (lev == 2 → 종료)
	    ├── (down) abc(2)   ⮑ path: [0, 1, 2]  (lev == 2 → 종료)
	```

- level: 얼만큼내려가냐 (바닥조건이라고 생각하기 맨위는 0 아래는 1...)
- branch: 얼만큼 퍼지냐
- ##### 111->112->113->114>121->122..->444이런식으로 출력하는 재귀구현
	- 레벨은 가로길이(**숫자의 자릿수**)로 설정하고 
		- int Path\[숫자리 자릿수]
	- 반복되는 숫자 개수 **(한 단계에서 퍼지는/가질수있는 숫자의 개수)** 만큼 branch로 설정하면 된다
		- 한 함수당 재귀호출반복횟수 i를 반복되는 숫자 개수만큼 설정
	- AA->AB....DD출력
		```c++
		char path[3];
		char name[5]="ABCD";
		void run(int lev) {
		if (lev == 2) {
		cout << path<<endl; //문자열로 만들면 한번에 출력가능
		return;
		}
		
		for (int i = 0; i < 4; i++) {
		path[lev] = name[i]//'A' + i; 
		run(lev + 1);
		path[lev] = '\0';
			}
		}
		```
	- LLL->LLM...이런식으로 LEFT, MIDDLE, RIGHT의 약어로 저장도 가능하다
		- char name\[4]="LMR"; 사용하면
- using 라이브러리 많이 쓰다보면 같은이름일때 충돌이 나타남
	- 그래서 생긴게 namespace이다
	- cout이라는 객체는 iostream 안에 있고, std라는 namespace에 속해있다
	- 이때 using을 쓰면 namespace를 생략할수있다
		1. **라이브러리를 많이 사용하다 보면, 같은 이름을 가진 요소(함수, 변수 등)들이 충돌할 가능성이 있음.**
			
			• 예를 들어, math.h와 cmath에서 같은 함수 이름이 있을 수 있음.
			
			• 이를 방지하기 위해 **각 요소를 특정 그룹(namespace) 안에 넣어 구별**할 수 있도록 함.
		2. **그래서 생긴 개념이 namespace(네임스페이스)이다.**
			
			• **네임스페이스는 같은 이름의 변수나 함수를 구분할 수 있도록 그룹화하는 기능을 함.**
			
			• 예를 들어, std::cout에서 std가 네임스페이스이고, cout은 그 안에 있는 객체임.
		3. **cout 객체는 iostream 라이브러리 안의 std 네임스페이스에 속해 있다.**
			
			• iostream 헤더 파일을 포함하면 std 네임스페이스 안에 있는 cout, cin, endl 등을 사용할 수 있음.
			
			• 하지만 std::cout처럼 매번 std::을 붙여야 한다.
		4. **using 키워드를 사용하면 네임스페이스를 생략할 수 있다.**
			
			• using namespace std; 를 선언하면, std::cout을 **그냥 cout으로 사용 가능**
			
			• 하지만 **전역적으로 using namespace std;를 선언하면, 다른 라이브러리와 충돌할 가능성이 있음.**
```c++
namespace BTS{
	int x;
	int sum;
}
namespace KFC{
	int x;
	int sum;
}

int main(){
	KFC::x=100;
	BTS::x=340;
}
```
- endl보다 '\n' 이 더 빠르다
- 코드이름 작성 기본적 일관적 틀
	- https://www.youtube.com/watch?v=dQzsgQnpufk
	- #### 변수명, 함수명: camelCase
		- **첫 단어는 소문자로 시작하고, 이후 단어의 첫 글자를 대문자로 표기**
	- #### 클래스명, 구조체명, 인터페이스명:  **PascalCase (파스칼 케이스)**
		- **모든 단어의 첫 글자를 대문자로 작성**
	- #### **전역 상수, 매크로 정의**: **SCREAMING_SNAKE_CASE**
		- **모든 문자를 대문자로 작성하고, 단어는\_(언더스코어)로 구분**
- 세부적 틀
	- 명확한 단어 사용하기, 줄임말 사용하지 않기 단어만 봐도 알수있게
	- 키워드에서 제공해주는 정보 중복으로 사용하지 않기
		- iage나 sname이런식으로 사용 x
	- 정확한 상속관계를 보여주는 명칭 사용하기
		- 부모클래스에 base같은 애매한 명칭을 사용하지 말고 자식 클래스를 더 상세히 정의
		- dog클래스만 존재했는데 일반화하려다가 부모클래스를 basedog로 하지 말자
			- base class basedog, class dog extends base dog 보단
			- base class dog, class puddle extends dog 이게 낫다
	- 단위를 알수있는 변수명 사용하기
		- 타입에서 알수없는 단위를 명시한 변수명 사용하기
			- length-> lengthMeters이런식으로
	- 함수에는 동사를 사용한다
		- file x -> readFile, writeFile
	- 같은 개념에 여러 용어 혼동해 사용하지 않기, 통일해서 하나만 사용하기
		- 가져오는걸 get으로 통일하기로 했으면 무조건 앞에 get붙이기 fetch,... x혼동해 사용 x
	- 발음하기 쉬은 이름 사용
		- 영어 발음에 약하면 길어도 두기
		- isAvible 이게 아니라 ->isAvailabe
	- 검색 가능한 이름 사용하기
		- OTP ->onetimepassword, ordertotalprice... 등등 많이 쓰임
		- 그래서 전체 검색했을때 이렇게 긴게 낫다 유지보수하려면
	- 언어별 스타일 준수하기
		- c++하던대로 java에서 선언 x
		- 자바만 하던사람이 헷갈림
## 훈련반 내가 작성한 코드의 개선점
- 입력받은 데이터를 변형하는 문제일경우, 원본를 변형하지말고 유지하자
	- 마스킹을 이용하자
- 현재 문자를 기준으로 이전 문자를 변경하면, 다음 반복에서 변경된 문자를 다시 확인하지 못해 일부 문자가 예상대로 처리되지 않을 수 있음.
	- 예:"ABCD"에서 ch1 = 'B', ch2 = 'C'일 때, A가 \#로 바뀌고 이후 B는 변경되지 않음.
	- 마스킹을 이용하자(변경이 필요한 문자를 먼저 기록한 후, 루프가 끝난 뒤 한 번에 변경하면 문제를 방지할 수 있음)
- 빈도수를 구하고 정렬시켜 출력
	```c++
	   for (int i = 0; i < 8;i++) {
		bucket[vect[i]]++;
	}
	 // 정렬된 출력, 원본을 훼손하지 않음

    for (int i = 0; i < 10; i++) {
        if (bucket[i] > 0) { 
            for (int t = 0; t < bucket[i]; t++)  
                cout << i << " ";
        }
    }
	```
- 👉 **”char 배열에 숫자를 저장하려면, 그냥 i+1이 아니라 i+'1'처럼 문자로 변환해야 한다!”**
	- 👉 **“그렇지 않으면, ASCII 코드 문제로 인해 cout << path;에서 이상한 값이 출력될 수 있다!”** 아스키코드 가 0+1인 이모티콘이 저장 vs 아스키코드가 0+49인 1이 저장
- 2차원배열
	- 1차원 배열이 여러개 있는것
- 3차원배열
	- 2차원 배열이 여러개 있는것
	- 그냥 네모난판이 아니라 1차원 배열 여러개이다.
- 재귀호출 비번뚫기 딱좋음
	- 모든수 입력하니
- for문을 너무 겹치는게 그럴땐 재귀호출씀
- 배열 크기를 입력받고 값들을 입력받을때->재귀호출 사용
- 배열 크기 고정이고 값들을 입력받을때 -> For 문
- 어려웠던 문제
	- 3x4배열에서 y=0, y=1, y=2일떄의 각각 수를 선택했을때 모든 조합과 그 조합의 합 이떄 재귀호출문으로
		- 이건
			선택되는 조합의 배열번호를 일부 나열하면
			00 10 20
			00 10 21
			00 10 22
			00 10 23
			이다 4개의 알파벳에서 3개를 선택하는 것과 같다.
			
			4개의 branch
			3개의 깊이
	- 3x4배열에서 y=0, y=1, y=2일떄의 각각 수를 선택했을때 모든 조합 이때 재귀호출+ 재귀호출의 아규먼트가 합으로 들어가야함
		- 이떄 이래야함
			```c++
			for (int i = 0; i < 4; i++) {
			    path[lev] = arr[lev][i] + '0';
			    run(lev + 1, sum + arr[lev][i]); // 이떄 sum+=arr[lev][i]이면 아래코드랑 다를바가 없음
			    path[lev] = 0;
			}
			
			```
			이렇게 코드짜면 틀림
			0000이렇게갔다가 000하고 1를 갈때 sum이 000이 아니라 0000일때의 합인 상태라 누적됨
			```c++
			sum += arr[lev][i];  // sum이 계속 누적됨
			run(lev + 1, sum);   // 다음 단계에 넘김
			```
- 사용자 입력을 배열로 크기로 받고싶어! c++과 자바의 차이
	- C++의 정적 배열은 컴파일 타임에 크기가 고정되어야 하기 때문에 사용자 입력을 크기로 사용하려면 new나 vector 같은 **동적 메모리 할당 방식**을 써야 해요.
	- 반면 자바는 배열 자체가 객체이기 때문에 항상 new를 사용해서 힙에 할당하므로, **런타임에 크기를 지정해도 아무 문제 없이 동작**합니다.
- path\[] 배열로 조합, 순열, 모든경우의 시도에 써먹을수있다.
- char input\[3]\[11]일때 3를 뽑아낼려면?
	- c++에서는 sizeof(input) / sizeof(input\[0])
		- sizeof(): **‘메모리 크기’를 바이트 단위로 반환**
		- strlen은 **널 문자(’\0’)를 끝의 기준으로 한 문자열의 길이(=문자 수)를 반환** 하는 함수
	- Java에서는 상관없음 **요소 개수**를 반환하는거라 Input.length해도 됨
	- 왜  c++은 길이를 직접구해주지 않고, java는 length로 깔끔하게 지원할까?
		- c++: 저수준언어에 가까움
			- 개발자가 메모리 직접통제하도록 설계됨
			- 배열은 단순한 메모리 덩어리
			- 단지 시작 주소만 있고, 끝이 어딘지는 모름
				- 그래서 배열의 길이를 자동으로 알수가 없어, 개발자가 수동으로 구해야 sizeof(input) / sizeof(input\[0])
				- 문자열도 char\[]로 표현 그래서 끝을 알게할 널 문자 삽입하는 방식을 사용하기 시작했고, strlen()이 등장함
				- **이중 배열을 위한 strlen() 같은 메서드가 없는 이유는,** **이중 배열이 문자열이라는 개념이 아니라, 단순한 “배열의 배열”로 취급되기 때문**
					- 왜냐면 “이중 배열 = 문자열 리스트”라는 규칙을 강제하려면, → 메모리, 타입 시스템, 컴파일러가 복잡해짐
					- 그래서 strlen2D() 같은 걸 만들려 해도, 각 행마다 널 문자가 있다는 **보장이 없음**
		- java: 고수준 언어로 추상화된 객체 중심언어
			- 모든 배열과 문자열이 객체임
			- 배열은 객체이고, 길이정부가 내부에 저장됨
			- 문자열도 클래스(string)으로 만들어짐
				- length는 단순한 메서드일뿐
			- 배열과 문자열에 대한 정보를 Jvm이 관리
	- 문자열들이 같은지 비교할때 사용할로직(지피티한테 칭찬받음)
		```c++
			int trueCount = 0;
			
			if (strcmp(a, b) == 0) trueCount++;
			if (strcmp(b, c) == 0) trueCount++;
			if (strcmp(c, a) == 0) trueCount++;
			
			if (trueCount == 3)  // WOW
			else if (trueCount == 2)  // GOOD
			else  // BAD
		``` 



