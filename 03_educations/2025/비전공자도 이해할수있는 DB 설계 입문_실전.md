## 섹션 1: OT
- 광범위한 이론보다 현업에 많이 쓰이는 20프로를 먼저 확실히 습득하자
- 내가 이해할수있는 직관적인 나만의 문장으로 정의하며 어렵게 공부해야 오래남는다


## 섹션 2: 시작전 필수로 알아야하는 개념

- ### 데이터베이스 모델링이란?
	- 데이터를 쉽게 조회하고 수정, 삭제하기위해 데이터를 어떻게 분류하고 저장할지를 설계하는 행위
	- DB설계라고도 한다.
	- 표준화된 데이터 저장을 위한게 데이터베이스 모델링 방법이다
		- 백엔드 개발자는 수많은 데이터를 다루니, 데이터베이스 모델링 방법을 배워 일관되게 데이터를 저장하자
- ### 관계형 데이터베이스의 기본구성
	- 관계형 데이터베이스는 여러 테이블로 구성되어있다.
		- 테이블은 열(컬럼,세로)과 행(로우,가로)으로 이루어져있다
- ### PK, FK
	- pk(기본키)
		- 데이터를 식별하기 위한 값
		- 중복 불가, 비어있을수없다
		- 주민번호와 같이 바뀔가능성이 적더라도 존재하는 실제 서비스의 데이터대신, 별개의 새로운 숫자 auto Increment(숫자 1씩 증가하는 방식)이나 UUID(랜덤값)으로 설정을 많이 한다
			- 바뀌면 특정 데이터를 식별하던 값이 바뀌어 데이터를 관리하거나 사용하는 입장에서 혼란
				- ex)개인정보 유출로 주민번호 폐지
	- FK(외래키)
		- 테이블을 분리해서 데이터를 저장하려면 다른 테이블의 데이터와 관계를 연결하기 위한 값이 필요
		- 주로 pk를 저장한다
		- 참조 무결성: 데이터베이스는 잘못된 fk를 넣을때 에러를 내서 방지해줌
			- 유저테이블의 pk는 2개까지인데, 게시글 테이블의 fk로 20를 넣으면 모순
	- 무결성: 이상하거나 말이 안 되는 값이 들어가지 않도록 보장하는 규칙
- ### 데이터베이스 네이밍 규칙
	- 현업자들이 쓰는 표준화된 이름 규칙
	1. 테이블명, 컬럼명을 소문자로만 작성한다
		- 대소문자 구분하는 운영체제, 안하는 운영체제 때문에
	2. 띄어쓰기를 표현할때는 snake_case를 사용하자
		- firstName이런 camel말고 first_name
	3. 축약어를 사용하지 않는다
		- 개발은 여려명이 하기에 가독성이 매우 중요하다
		- 그 어떤 개발자가 보더라도 직관적이게 짓자
			- fst_nm-> first_name
		- 최근의 개발트렌드는 코드 길어져도 괜춘 가독성이 더 중요
			- 20자되는 변수명도 있다.
	4. SQL문을 작성할때 예약어만 대문자로 표현하자
		- SQL문법 자체는 대소문자를 따로 구분하지 않는다
		- 그러나 가독성을 위해 대문자로 작성하자
	5. 복수명으로 테이블명을 짓자(선택)
		- 회사마다 갈린다 하나만 정하고 그대로 쭉 가는 일관성이 중요하다
			- 어떤 테이블은 단수, 다른테이블은 복수 이런거 안됨

---
## 섹션 3: DB설계의 핵심원칙 및 전제과정

- ### 설계할때 이런 개념은 몰라도 된다
	- DB실전 설계하고 이해해도 되는 개념
	- 후보키, 대체키, 슈퍼키 몰라두 됨
	- 개체- 관계 모델
	- 모델링 과정
	- 이상현상
	- 함수 종속성
	- N정규형
- ### 설계시 이 한가지만 꼭 기억해야할 핵심 원칙 1가지
	- ### 중복 없애기
		- 중복만 없어도 잘 설계한거다
		- 중복된 데이터가 있으면 데이터의 변경이 있을때 다른 테이블의 모든 그 데이터를 고쳐야한다
			- 일일히 다 고쳐야한다
			- 그럼 실수로 누락되는 경우가 생길수있다
				- 박재성이 박지성으로 갱신이 되지않았다
				- 이를 이상현상이라고 한다
		- 중복을 없애자==> 정규화 하자
	- 정규화
		- DB를 설계하면서 중복을 없애는 방법
		- 실제 현업에서는 1,2,3 정규형 까지만 한다
			- 다른 정규화는 너무 테이블 분리한다.
- ### 설계 전체 과정
	1. UI를 보고 저장해야하는 데이터 파악하기
		- 데이터베이스를 설계하기 전에 어떤 데이터를 저장해야하는지 파악해야한다. 그럴려면 대략적인 UI 디자인이 나와있어야한다.
	2. 그룹핑해서 분류하기
		- 저장해야 하는 데이터를 묶어서 그룹핑할 수있는 상위개념을 찾아야한다
			- 아이디, 패스워드, 이름, 이메일->사용자
			- 영화이름, 영화에 출연한 배우, 영화상영시간->배우
		- 이떄 그룹핑한 상위개념을 엔티티라고 말하고 테이블로 나타낸다.
	3. 분류한 테이블에 6가지 규칙 적용시키면서 테이블 분리해나가기
- ### 저장할 데이터 파악, 그룹핑해서 분류
## 섹션 4: DB설계규칙 6가지
- #### 1. 한 칸에는 한가지 정보만 넣는다
	- 이유
		- 두가지 정보가 들어갈때, 정보 조회시 구분점을 제거하고 난뒤에 배열에 집어넣는 로직을 넣어야 하는데, 삽입할때든 삭제할때든 항상 구분점을 신경써서 작업해야한다
		- 한칸에 데이터를 여러개 집어넣다보면 실수로 데이터를 중복해서 넣어버리기도 한다.
		- 정렬/검색/필터 기능 사용이 불편해짐
	- 한가지 정보의 기준: 무엇이 '한 가지 정보'인지의 판단은 **해당 데이터가 실제로 나의 서비스에서 어떻게 사용되는지**에 따라 결정된다.
	- ### 내 서비스의 사용방식으론 한칸에 여러정보 같다면?-> 2가지 대응 방법
		- 고정된 단일값이고,
		- 변하지 않거나, 변경이력추적이 불필요하고,
		- 다른 테이블에서 참조하거나 연결하지 않고
		- 단순히 WHERE, ORDER BY, GROUP BY 등에 쓰이는 경우 
		- #### 1_1 컬럼으로 분리한다
			- 이름을 성+이름의 조합으로 본다면? 이름은 한가지 정보일수도, 두가지 정보일수도 있다 
				- 내가 성과 이름을 따로따로 조회하는 서비스라면 
					- id, 성, 이름의 구성의 테이블을 만들어 가져와야하는 수고를 줄인다
				- 이름을 통채로 조회하는 서비스라면
					- id, 이름의 구성의 테이블
			- 전화번호
				-  지역별 구별하는경우엔 
					- Id ,전화번호1, 전화번호2, 전화번호3
					- 031/264/8342 따로 저장
		- 만약 
			- 여러개의 정보이고
			- 변경 이력/ 다건 저장이 필요한 정보이며
			- 다른엔티티와 연결되거나
			- **통계·분석의 기준 단위로 사용되며 정렬/필터 기준이 자주 바뀌는 경우**
		- #### 1_2 별도의 엔티티(테이블)로 분리하고 FK를 도입한다
			- 유저의 이메일이 2개다
			- -> 유저테이블 뿐만 아니라 이메일 테이블도 추가해 분리한다.
			- 이때 연결을 어떻게 해야하지?
				1) 기존 테이블에 이메일 테이블 id(FK)로 연결해본다 이래도 원칙1이 지켜지지 않는다면
				2) 분리한 테이블에 테이블에 사용자 Id(FK)를 연결해본다. 이래도 원칙1이 지켜지지 않는다면
				3) 중간테이블을 만들어 두 테이블 FK를 모두 넣어준다
				4) 헷갈린다면 규칙3
			- 그럼 사용자 A의 모든 이메일들을 조회하려면 어떻게 해야하지?
				- 이메일 테이블에서 사용자id(FK)를 필터링하면 모두 조회가능
	- 결국 기획방향, 변경에 따라 데이터의베이스의 설계가 달라진다.
- #### 2. 기존테이블에,별도로 분리한 테이블에 fk 넣어봐도 모두 규칙 1이 어긋난다면 중간 테이블을 하나 더 만들어라
	- 처음엔 students_courses 처럼 단순히 이름을 지어주고
	- 분리한테이블, 기존테이블의 fk를 모두 넣어준다
		- students
			- id, name
		- courses
			- id, course
		- course_registrations
			- id, student_id(FK), course_id(FK)
	- 이후 두 테이블을 연결하는 중간테이블의 이름은 기존, 별도로 분리한 테이블명을 각각 보고 둘 사이의 관계의 동사로 지어준다
		- 중간 테이블명을 보고 내용을 짐작할수있는 동사로 다시 짓는다
		-  course_registrations으로
		- 배우와 영화를 연결하는 중간테이블의 경우 casting(캐스팅)으로
- ### 3. 각각 PK넣어보는 방식이 헷갈린다면 엔티티간의 관계를 파악해보자(1:1, 1:N, N:M)
	- #### 3_1: 엔티티들 간에 어울리는 공통의 동사 찾기
		- A가 주어) A가 B를  \_.
		- B가 주어) B가 A에 의해 \_.
			- 동사는 서비스의 관점에서 떠올려야한다
	- #### 3_2: 1번과정에서 찾은 동사를 활용해 적절한 단어찾기
		- A의 관점) 하나의 A는 (하나/여러 개)의 B를 3_1동사
		- B의 관점) 하나의 B는 (하나/여러 개)의 A에의해 3_1동사
		- 각 관점앞에 '하나의' 라는 단어를 붙여야 헷갈리지 않는다.
		- 서비스의 기획에 따라 달라지기에 반드시 자신의 서비스에만 대입해서 생각해야한다.
	- #### 3_3:  3_2의 문장에서 관계 파악하기
		- 1) A,B 모든 관점에서 전부 '하나'를 가진다면 A:B -> 1:1 관계이다
		- 2) A의 관점에서는 '여러개'의 B를 가지고, B의 관점에서는 '하나의' A를 가진다면 A:B -> 1:N 관계이다..
		- 3) A의 관점에서는 '하나'의 B를 가지고, B의 관점에서는 '여러개'의 A를 가진다면 A:B -> N:1 관계이다
		- 4) A,B 모든 관점에서 전부 '여러개'를 가진다면 A:B -> N:M 관계이다
		- 예시: 가게,판매상품
			- 하나의 가게가 여러개의 판매상품을 판다
			- 하나의 판매상품은 하나의 가게에 의해 팔린다
				- 하나의(각 가게마다 단독상품인 서비스 제공시)
				- 여러개(공통된 상품을 파는 서비스 제공시)
			- 1(주어):N(목적어)이군
	- #### 3_4: 각 관계에 맞게 FK를 넣어준다.
		- 1:N, N:1: N쪽의 테이블에 FK가 들어가야한다.
		- N:M의 관계에서는 중간테이블을 추가함으로써 1:N의 관계로 바꾸어 표현한다.
			- 중간테이블이 반드시 있어야 한다
			- 중간테이블에 두 테이블의 FK를 넣어준다
## 섹션 5: DB설계 해보기

## 섹션 6: 설계한 모델을 실제 DB에 반영하기

## 섹션 7: DB설계 Q&A

## 섹션8: 마무리

