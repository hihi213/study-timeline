1.     과제 개요 (Overview)
	 -     TCP/UDP, 멀티스레딩, 채팅 서버, 파일 전송 등 어떤 기술을 중점적으로 다뤘는가?
		본 프로젝트는 TCP 기반의 텍스트 명령어 기반 채팅 서버 및 클라이언트를 구현하는 과제입니다. 멀티스레딩을 활용한 동시 접속 클라이언트 처리, 명령어 기반의 채팅방 관리 및 귓속말 기능 구현을 중심으로 설계되었습니다. 서버는 다수의 채팅방을 생성∙관리하고, 클라이언트는 원하는 채팅방에 접속하여 실시간 대화를 할 수 있습니다본 과제는 TCP/IP 기반의 멀티스레드 채팅 서버 및 클라이언트 시스템 구현을 중심으로 한 네트워크 프로그래밍 프로젝트입니다. 주요 기술 요소는 다음과 같습니다
		TCP 소켓 통신: 본 시스템은 신뢰성 있는 양방향 통신을 구현하기 위해 TCP 프로토콜을 기반으로 설계되었습니다. 클라이언트와 서버는 각각 socket(), bind(), listen(), accept(), connect() 등의 시스템 호출을 통해 연결되며, 실시간으로 텍스트 데이터를 송수신합니다.
		멀티스레딩: 서버는 다수의 클라이언트가 동시에 접속하고 독립적으로 채팅할 수 있도록, 클라이언트마다 별도의 스레드를 생성하여 병렬적으로 메시지를 처리합니다. 이를 통해 서버는 여러 사용자로부터의 요청을 비동기적으로 처리하며, 스레드 간 데이터 충돌을 방지하기 위해 mutex 등의 동기화 기술도 일부 사용됩니다.
		채팅 서버 구현: 채팅방의 생성, 삭제, 입장, 퇴장, 메시지 중계, 사용자 리스트 관리, 닉네임 중복 방지, 귓속말 등 채팅 애플리케이션에서 요구되는 핵심 기능들을 명령어 기반 인터페이스로 구현하였습니다.
		텍스트 기반 명령어 처리: 사용자는 /create, /join, /nick, /list, /exit, /quit, /w 등의 텍스트 명령어를 입력하여 채팅방과 상호작용할 수 있으며, 서버는 이를 파싱하여 적절한 동작을 수행합니다.
		본 과제에서는 파일 전송 기능은 포함되지 않았으며, 대신 텍스트 기반 채팅의 기능적 완성도와 구조적 안정성에 중점을 두었습니다. 이를 통해 TCP 기반 통신의 신뢰성과 멀티스레딩의 병렬성, 그리고 사용자 인터페이스 설계에 대한 실무적 감각을 학습하고자 하였습니다
2.     요구사항 및 기능 정의
	-  클라이언트와 서버가 각각 어떤 역할을 수행하는지
		서버는 TCP 기반으로 동작하며, 클라이언트의 접속 요청을 수락하고 각 클라이언트에 대해 별도의 스레드를 통해 메시지를 처리하는 구조입니다. 다음과 같은 주요 기능을 수행합니다:
		1. **TCP 기반 소켓 통신 처리**  
		   서버는 `socket()`, `bind()`, `listen()`, `accept()` 호출을 통해 TCP 연결을 수립하고, 클라이언트 접속을 처리합니다.
		2. **접속된 클라이언트 수 관리**  
		   서버는 현재 접속 중인 클라이언트의 수를 추적하며, 전체 클라이언트 수에 대한 제한은 없지만 채팅방 입장 시 방 인원 제한이 적용됩니다.
		3. **채팅방 생성 및 관리**  
		   최대 10개의 채팅방을 생성 가능하며, 각 방에는 최대 40명의 사용자가 동시에 입장할 수 있습니다.  
		   클라이언트가 `/create <방이름>` 명령어를 통해 새 채팅방을 요청하면 서버는 방 목록에 추가하고 고유 방 번호를 할당합니다.
		4. **채팅방 리스트 전송**  
		   클라이언트가 `/list` 명령을 보내거나 접속 시, 서버는 현재 채팅방 목록과 인원 수를 클라이언트에게 전송합니다.
		5. **입장/퇴장 처리**  
		   사용자가 `/join <번호>`를 통해 채팅방에 입장하거나 `/exit`으로 퇴장할 수 있으며, 서버는 이를 해당 방의 모든 사용자에게 안내합니다.
		6. **메시지 브로드캐스트**  
		   채팅방 내 메시지는 같은 방 사용자 전체에게 브로드캐스트되며, `닉네임: 메시지내용` 형식으로 전달됩니다.
		7. **귓속말 기능 처리**  
		   `/w <닉네임> <메시지>` 명령을 통해 서버는 지정된 사용자에게만 비공개 메시지를 전송합니다.
		8. **닉네임 중복 방지 및 사용자 상태 관리**  
		   동일한 채팅방 내에서는 닉네임 중복이 불가능하며, 서버는 중복 시 에러 메시지를 반환합니다. 클라이언트가 종료하면 해당 유저 정보는 서버 상태에서 제거됩니다.
		9. **스레드 기반 동시 처리**  
		   서버는 각 클라이언트 소켓에 대해 독립적인 스레드를 생성하여 병렬적으로 메시지를 수신 및 처리합니다.
	-  클라이언트는 사용자가 서버에 접속하여 채팅 시스템을 이용할 수 있도록 하는 역할을 수행하며, 명령어 기반의 텍스트 인터페이스를 통해 서버와 통신합니다. 주요 기능은 다음과 같습니다:
		1. **닉네임 설정**  
		   프로그램 실행 직후 닉네임을 설정해야 하며, 동일 채팅방 내에서 중복 닉네임은 허용되지 않습니다. `/nick <닉네임>` 명령어를 통해 언제든 변경이 가능합니다.
		2. **서버 접속 및 채팅방 목록 수신**  
		   클라이언트는 서버의 IP와 포트를 이용해 `connect()`를 통해 TCP 연결을 시도하며, 접속에 성공하면 서버로부터 채팅방 목록을 수신받습니다.
		3. **채팅방 생성 및 입장**  
		   사용자는 `/create <방이름>` 명령어를 통해 새로운 채팅방을 생성하거나, `/join <번호>`를 통해 기존 방에 입장할 수 있습니다. 서버는 방 생성 또는 입장 여부를 응답으로 전달합니다.
		4. **메시지 입력 및 송수신 처리**  
		   일반 메시지를 입력하면 현재 접속 중인 채팅방 내 사용자들에게 브로드캐스트되며, 서버를 통해 중계됩니다. 수신 메시지는 실시간으로 화면에 출력됩니다.
		5. **귓속말 기능 (/w)**  
		   `/w <닉네임> <메시지>` 명령어를 통해 특정 사용자에게만 메시지를 전송할 수 있으며, 서버는 대상 닉네임을 검색하여 해당 사용자에게만 전송합니다.
		6. **사용자 리스트 확인 (/list)**  
		   현재 채팅방에 있는 모든 사용자 닉네임을 확인할 수 있으며, `/list` 명령어를 통해 서버에 요청합니다.
		7. **채팅방 나가기 및 종료 처리**  
		   `/exit` 명령을 통해 현재 채팅방을 나올 수 있으며, `/quit` 명령을 입력하면 프로그램이 종료되고 서버와의 연결이 끊깁니다.
		8. **명령어 기반 사용자 인터페이스**  
		   모든 상호작용은 텍스트 명령어 기반으로 수행되며, 잘못된 명령 입력 시에는 서버 또는 클라이언트에서 오류 메시지를 출력하여 사용자에게 안내합니다.
	- 동시 접속 처리, 메시지 전송 방식, 연결 유지 방식 등 주요 기능 설명
		1. **동시 접속 처리**  
		   서버는 클라이언트의 TCP 접속 요청을 수락(`accept()`)한 후, 각 클라이언트 소켓에 대해 **독립적인 스레드**를 생성하여 메시지를 처리합니다. 이를 통해 최대 10개의 채팅방 × 40명, 즉 최대 400명까지 병렬적으로 접속 및 통신이 가능합니다. 각 채팅방 내부 사용자 리스트와 메시지 처리는 스레드 간 충돌 방지를 위해 mutex로 보호됩니다.
		2. **메시지 전송 방식**  
		   채팅방 내 일반 메시지는 서버가 수신한 후, 해당 채팅방에 속한 모든 클라이언트에게 **브로드캐스트 방식으로 전송**됩니다. 귓속말 메시지(`/w`)는 닉네임을 기반으로 특정 사용자에게만 전송됩니다. 모든 메시지는 텍스트 기반이며, 특정 규칙에 따라 구분자(`|`)를 사용해 파싱합니다.
		3. **연결 유지 방식**  
		   클라이언트와 서버는 TCP 소켓을 통해 **지속적인 연결(persistent connection)**을 유지하며, 클라이언트가 명시적으로 `/quit` 또는 종료 명령을 내릴 때까지 연결이 유지됩니다. 연결 종료 시 서버는 해당 클라이언트의 정보를 사용자 리스트 및 채팅방에서 제거합니다. 비정상 종료나 네트워크 오류 발생 시에도 스레드 정리 및 사용자 상태 갱신 처리를 수행합니다.
3.     네트워크 설계 (Network Architecture)
	-  클라이언트-서버 구조 다이어그램
	-  데이터 흐름도 또는 통신 흐름도 (예: 요청 → 응답 순서)
	-  사용하는 프로토콜(TCP/UDP) 선택 이유 및 장단점.
		본 과제에서는 TCP(Transmission Control Protocol)를 사용하였습니다. TCP는 신뢰성 있는 데이터 전송을 보장하는 연결 지향형 프로토콜로, 패킷 유실이나 순서 꼬임 없이 데이터를 정확하고 안정적으로 전달할 수 있습니다. 또한 클라이언트의 상태를 유지한 채 양방향 통신이 가능하며, 메시지의 순차적 전송이 보장되어 실시간 채팅 서비스에 적합합니다. 반면, UDP(User Datagram Protocol)는 전송 속도는 빠르지만 패킷 유실 및 순서 보장이 되지 않아 메시지의 신뢰성과 일관성이 요구되는 채팅 시스템에는 적합하지 않으며, 연결 상태를 유지해야 하는 서버-클라이언트 구조에서 구현이 복잡해지는 단점이 있습니다.
	- 포트, IP, 스레드 구조 등 기술적 설정 사항
4.     프로토콜 설계 또는 메시지 포맷 정의 (Optional but Recommended)
	- 직접 설계한 메시지 형식 (예: HEADER|DATA|FOOTER)
		고정길이 데이터 전송 방식은 송수신자가 항상 일정한 크기의 데이터를 주고받기 때문에, 짧은 메시지일 경우 공간 낭비가 발생하고 긴 메시지일 경우 손실될 수 있어 유연성이 요구되는 채팅 환경에는 적합하지 않습니다. 데이터 전송 후 연결을 종료하는 방식은 하나의 메시지를 보낼 때마다 연결을 새로 맺어야 하므로, 연결을 유지한 채 여러 메시지를 주고받아야 하는 채팅 프로그램에는 비효율적입니다. 가변길이 전송 방식은 메시지 끝에 특수 구분자(EOR)를 붙이는 방식으로 간단하긴 하지만, 메시지 내용 중 구분자와 동일한 문자가 포함될 경우 메시지 경계를 잘못 해석할 수 있어 신뢰성이 떨어집니다. 따라서 본 프로젝트에서는 고정된 길이로 데이터 크기를 먼저 전송한 뒤, 해당 길이만큼의 데이터를 정확히 수신하는 ‘고정길이 + 가변길이’ 전송 방식을 채택하였습니다. 이와 함께 클라이언트와 서버 간 명확한 메시지 해석을 위해 HEADER|DATA 형식의 메시지 구조를 설계하였습니다. HEADER에는 메시지 유형(type), 송신자(sender), 대상 채팅방(room), 데이터 길이(length) 등의 메타정보를 포함하였고, DATA에는 실제 채팅 메시지 또는 명령어 인자를 담도록 구성하였습니다. 해당 구조는 TCP 통신에서의 메시지 경계 구분 문제를 해결할 뿐만 아니라, 방 생성, 입장, 퇴장, 귓속말, 사용자 목록 요청, 닉네임 변경 등 다양한 기능을 하나의 통합된 메시지 틀로 처리할 수 있도록 설계되었습니다.
		typedef struct {
		    char type[MAX_TYPE];     // 메시지 유형 (e.g. "MSG", "NICK", "JOIN", "WHISPER", "LIST", "EXIT", "QUIT")
		    char sender[MAX_NICK];   // 보낸 사람 닉네임
		    char room[MAX_ROOM];     // 방 이름 or 방 번호 (문자열로)
		    int  length;             // data 필드의 유효 데이터 길이
		    char data[MAX_DATA];     // 실제 메시지 or 명령어 인자
		} ChatMessage;
	- 클라이언트-서버 간 송수신 메시지 구조 및 처리 방식
		클라이언트와 서버는 ChatMessage 구조체를 기반으로 모든 메시지를 송수신합니다. 각 메시지는 구조체 단위로 직렬화되어 전송되며, 수신 측에서는 고정된 크기만큼 데이터를 수신한 뒤 type 필드를 기준으로 처리 루틴을 분기합니다. 클라이언트는 메시지를 전송할 때, 구조체에 필요한 정보를 채운 후 send() 함수를 이용해 구조체 전체를 전송합니다. 서버는 이를 수신하여 메시지 유형과 내용을 파악한 뒤, 명령어 처리 혹은 메시지 전파 등의 동작을 수행합니다.
		
		
		예를 들어 클라이언트가 “/join 2” 명령을 입력하면, 해당 메시지는 type에 “JOIN”, room에 “2”, sender에 현재 닉네임이 포함된 구조체로 구성되어 서버에 전달됩니다. 서버는 이를 해석하여 사용자를 해당 채팅방으로 이동시키고, 다른 사용자에게 입장 알림을 전송합니다. 반대로 서버가 “MSG” 유형의 메시지를 전송하면, 클라이언트는 이를 수신하여 화면에 출력하게 됩니다. 이와 같은 구조를 통해 서버와 클라이언트는 명확하고 일관된 메시지 해석 및 처리를 수행할 수 있습니다.
5.     구현 세부 설명 (Implementation Details)
	- 주요 모듈/클래스 역할 설명
	- 통신 관련 로직 (socket 연결, bind, listen, accept 등) 설명
	- 멀티스레딩, select/poll, 비동기 방식 사용 여부 설명
6.     실행 결과 (Execution & Output)
	- 클라이언트 시작
	- 채팅방 목록 확인 (3명 이상의 client 접속)
	- 새 채팅방 생성
	- 새 채팅방에서의 채팅 화면
	- 기존의 채팅방 입장
	- 채팅방 내 사용자 리스트 보기
	- 기존의 채팅방에서의 채팅 화면
	- 귓속말 사용
	-  닉 네임 변경
	-  방 나가기 및 종료
7.     어려웠던 점 및 해결 방법
	일단 초반부터 이걸 어떻게 해야할지 막막했다. 그래서 잘게 쪼개서 순서대로 구현하기로 했다
8.     개선 사항
	-     요구사항 이외 개선한 사항




## 4. 프로토콜 설계 및 메시지 포맷 정의

본 시스템은 C 언어에서 구조체를 활용한 **고정된 메시지 포맷 기반의 TCP 메시지 송수신 방식**을 사용합니다. 클라이언트와 서버는 고정 크기의 구조체 데이터를 주고받으며, 필요 시 내부 필드에 따라 메시지 종류와 처리를 구분합니다. 

### 4.1 메시지 형식 (C 구조체 표현)

메시지는 다음과 같은 구조체를 통해 표현됩니다:

```c
#define MAX_MSG_LEN 256
#define MAX_NAME_LEN 32

typedef struct {
    int type;                  // 0: 일반 메시지, 1: 명령어, 2: 귓속말 등
    char sender[MAX_NAME_LEN];
    char target[MAX_NAME_LEN]; // 귓속말 대상자 (없을 경우 빈 문자열)
    char message[MAX_MSG_LEN]; // 메시지 본문
} ChatMessage;
````

- **type 필드**를 통해 서버는 해당 메시지가 일반 채팅, 명령어, 귓속말 중 어느 유형인지를 식별합니다.
    
- 모든 메시지는 send()와 recv()를 통해 고정된 크기로 주고받습니다.
    

  

### **4.2 데이터 전송 방식**

- **고정 길이 전송 방식**을 기반으로, 클라이언트와 서버 모두 sizeof(ChatMessage) 만큼의 버퍼를 항상 사용하여 데이터를 송수신합니다.
    
- 전송 시, 바이트 수는 항상 일정하며, 미사용 영역은 \\0으로 채워지거나 무시됩니다.
    

  

> 예시: send(sockfd, &msg, sizeof(ChatMessage), 0);

  

이러한 방식은 파싱이 필요 없고, 구조체 내부 필드를 직접 접근할 수 있어 구현이 간결해집니다. 다만 이진 전송 방식의 특성상 **바이트 정렬(Padding), 엔디언 차이** 등 플랫폼 간 전송 시 유의점이 존재합니다.

  

### **4.3 수신 처리 방식 (서버 측)**

  

서버는 수신된 구조체를 다음과 같이 처리합니다:

```
ChatMessage msg;
recv(client_sock, &msg, sizeof(msg), 0);

switch (msg.type) {
    case 0:
        broadcast_message(msg);
        break;
    case 1:
        handle_command(msg);
        break;
    case 2:
        send_whisper(msg);
        break;
}
```


