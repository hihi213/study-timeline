- 요약: 유심 털림
- 초기 악성코드 유입은 **피싱메일과 웹서버 취약점**을 통했을 가능성이 가장높은 상황
- 공격은 매우 긴 시간에 걸쳐 이뤄졌을 것이고 하위 시스템으로부터 점진적으로 권한을 높여 HSS에 접근했을것으로 확실
- 어떻게 대응했어야했나?
	- 공격자는 흔적없어 탐지및, 대응 솔루션만으로 해킹을 방지할수 없다
	- 평상시 웹쉘 활동과 비정상 프로토콜 트래픽을 다계층으로 탐지
	- 데이터량이 너무 많아 포트미러링해서 모니터링 실시간 분석이 쉽지 않다.
	- 분석이라는게 실시간으로 이루어져야하는데 이게 너무너무 어렵다
	- ssd에 저장해서 분석해야하는데 저장 자체가 지금 기술이다. 정말 쉬운일이 아니다
- sk 서버공격은 BPF도어를 활용해서 일어났다
	- BPF: 네트워크패킷을 효율적으로 필터링하려고 만들어진 커널 안쪽기능 skt 사용하다가 BPFDOOR라는 해킹수법 이용한 해커들한테 정보털림
	- 커널 안쪽 기능이라 **BPF가 뚫리면 커널을 우회/변조할 수 있다**
	- **서버가 뚫렸다는 걸 관리자도 모르고 넘어갈 수 있다.** (BPF는 커널 모듈처럼 정상 동작처럼 보임)
- BPF기술을 사용해 socket통신이 아닌 로우 패킷 직접 조작방식으로 통신
	- 소켓을 아예열지 않음 패킷을 직접 조작하는 방식이라 tcp,udp,icmp모두 가능하고 포트 스캔으로는 탐지 불가
	- reverse shell제공해 시스템 원격제어가능-> 시스템 탈취됨
	- 즉 skt내부에 Hss라는 요소에 특정 서버가 있는데 이 서버에 악성코드가 올라갔고 그 서버가 탈취가 됐다.
- 21년도에  pwc위협 보고서에 공개된 악성코드이다 이건 중국기반 해킹그룹이 오픈소스로 공개했다
	-  깃허브 bpfDOOR라고 이미 소스코드가 공개되어있다
	- 이미 알려진 수법
- BPF 작동원리
	- 정상적인 소켓통신체게
		- 서버 작동하기 위해선 소켓을 열어야한다 이때 소켓은 파일+ 포트정보이다.
		- 포트번호가 바인딩되고 nic를 움직여서 네트워크로 정보이동
	- 와이어샤크 같은 새로운 통신체게
		- 소켓대신 
- 위버엔트 수법과 닮았다
	- 중국 해킹 조직 위버엔트의 공격수법과 유사하다
	- 국가 기반시설노림
	- 21년부터 아시아 대형 이동통신사 네트워크에 침투해 활동
	- 인메모리 기반 웹쉘을 사용해 2차 메모리에 기록을 남기지 않는것이 특징
	- 주요통신내용은 AES알고리즘으로 암호화(탐지 우회)



자신의 서버/서비스를 최소 권한으로 운영**한다. (root 권한 남발 금지)
**운영 중인 서버에는 절대 불필요한 BPF 프로그램/커널 모듈을 설치하지 않는다.**
네트워크 관련 프로그램(BPF 등)은 철저히 코드 리뷰**하고 배포한다.
**서버 접근 시 인증 강화 (MFA, 키 인증)**를 적용한다.
**정기적으로 커널/패키지 보안 업데이트**를 한다. (특히 커널 취약점 패치)
|**모든 수상한 트래픽은 로그로 남기고 주기적 분석**한다.
**네트워크 모니터링 시스템 자체를 보호**해야 한다. (모니터링 시스템이 뚫리면 끝임)

BPFDoor는 다음과 같은 단계로 작동합니다:
	1.	스텔스 기법 적용:
	•	프로세스 이름 변경(masquerading): 정상적인 시스템 프로세스로 위장
	•	타임스톰핑(timestomping): 파일 타임스탬프 변경으로 흔적 은폐
	•	환경 정보 초기화로 추적 방지
	2.	패킷 필터링 및 백도어 활성화:
	•	BPF를 사용하여 효율적으로 네트워크 트래픽 모니터링
	•	특정 매직 패킷(TCP: 0x5293, UDP/ICMP: 0x7255)을 필터링
	•	올바른 비밀번호와 함께 매직 패킷을 받으면 활성화됨
	3.	방화벽 우회 및 리버스 쉘:
	•	로컬 방화벽을 수정하여 공격자 IP의 접근을 허용
	•	리버스 쉘을 열어 더 깊은 침투 가능
	•	RC4 암호화를 사용한 비밀번호 보호


| **단계** | **설명**                                                            |
| ------ | ----------------------------------------------------------------- |
| 1      | **BPF 기반 백도어 설치**                                                 |
|        | - 해커가 서버에 침투한 후, **BPF 소켓**(low-level packet capture 기능)을 열어서 설치함 |
| 2      | **패킷 감청(스니핑)**                                                    |
|        | - 서버가 받은 **모든 네트워크 패킷**을 몰래 관찰함 (하지만 일반적인 TCP 포트 리슨이 아님)          |
| 3      | **특정 “패턴”이 있는 패킷을 감지**                                            |
|        | - 누군가가 “특정 패턴” (예를 들면, 암호화된 특수 문자열)을 넣은 패킷을 보내면, 이걸 보고 알아챔        |
| 4      | **명령어 수신**                                                        |
|        | - 해커는 패킷에 몰래 명령어를 숨겨서 보냄 (ex: 파일 읽어, 쉘 열어 등)                      |
| 5      | **명령어 실행 & 결과 은폐**                                                |
|        | - 서버 안에서 몰래 명령어를 실행하고, 그 결과를 다시 감춰서 외부로 보내줌 (일반 트래픽처럼)            |
| 6      | **네트워크 포트 열지 않고 제어**                                              |
|        | - netstat 같은 툴로 봐도 **“열린 포트”가 안 보임**, 방화벽에도 안 걸림                  |

  
- 커널 안에서 실행되니까 감지, 차단이 엄청 어려움

# **✨ 핵심 요약**

  

> BPFDoor는 **포트를 열지 않고**, BPF 필터를 **정상적인 것처럼 등록**한 다음,

> **패킷 자체를 감청해서** 명령을 받고,

> **시스템을 몰래 조종하는 백도어**였다.

---

# **🧠 BPFDoor가 무서운 이유**

| **이유** | **설명**                                                                                                                                                          |
| ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 🚨     | **서버에 열린 포트가 없음** (보통 백도어는 포트 열리는데 얘는 안 열림-> netstat, lsof, 방화벽 로그로도 “수상한 포트”가 안 보인다.)                                                                          |
| 🚨     | **패킷 안에 몰래 명령이 숨어 있어서 탐지 어렵다**<br>(= 서버가 초당 수천 수만 패킷을 받는데, 거기 숨으면 진짜 찾기 어렵다.)<br>(= 기존 정상 트래픽 흐름에 몰래 껴서 움직인다.)<br>(= “특정 암호화된 신호”를 가진 패킷만 반응한다. → 평소에는 조용히 있다.) |
| 🚨     | **일반 방화벽, IDS(침입탐지시스템)로 탐지 거의 불가능**<br>(= 전체 트래픽을 하나하나 다 검사하면 서버가 느려져서 실무에서는 불가능하다.)                                                                            |
| 🚨     | **커널 레벨에서 작동**해서 흔적도 최소화 가능<br>(= 사용자 공간(User Space) 모니터링 툴로는 아예 안 보인다.)                                                                                        |

  

---

# **📷 그림으로 보면**

```
[공격자] ---[패킷 숨김]---> [서버 내부 BPF 감시] ---[명령 실행]
```

_(포트를 열지도 않고, 오로지 패킷만으로 컨트롤)_

---

# **✨ BPFDoor와 일반 백도어 비교**

|**항목**|**일반 백도어**|**BPFDoor**|
|---|---|---|
|포트 열림|열려있음 (예: 1337포트 등)|없음|
|탐지 쉬움|네트워크 스캔으로 발견 가능|거의 탐지 불가|
|네트워크 감시 방식|리슨(대기)|패킷 감청 (스니핑)|
|난이도|중|상 (커널 지식 필요)|

  

---

# **🚨 현실 결론**

  

> **BPFDoor = 고급 해커가 “최대한 들키지 않고 서버를 조종하려고 만든 백도어”**

  **“모든 기술은 악용될 수 있다.”**

- BPF → 네트워크 최적화 도구로도 훌륭하지만,
    
- BPF → 해커가 쓰면 완벽한 감청 시스템이 된다.


BPF 코드는 굉장히 저수준(bytecode)이라서 - 등록된 필터가 정상적인 캡처 필터인지, 악성인지 **자동으로 분석하는 게 거의 불가능**하다.


암호화폐가 진짜 돈처럼 쓰일때가 되면 양자컴퓨터 기술 발전해서 뚫릴수있음
양자: - 평소에는 **0과 1** 둘 다 가진 “흐릿한 상태(중첩)“로 있어. (=> 동시에 0도 1도 맞음 )**‘자유롭게 동시에 가지다가, 측정하면 하나로 뚜렷하게 고정되는** 특성을 가진 물질 시스템
“양자 상태는 동시에 여러 값을 가진다는데,  상태가 고정돼야 데이터가 안정적인 거 아냐? 그러면 계산을 어떻게 정확하게 하지?”
-  고전 컴퓨터: 
	- 0 아니면 1
	- 예를 들면, 000, 001, 010, …, 111 이렇게 8개 경우를
	- **하나하나 따로따로 계산**해야 해. > 사과 하나하나 따로 바구니에 담는다
- 양자 컴퓨터
	- 000~111 전부 중첩시켜 한 번에 계산 계산 중에는 흐릿하게 유지, 측정할 때만 고정된다.
	- 사과, 배, 포도, 귤을 **한꺼번에** 한 바구니에 **“겹쳐서”** 들고 있고, “모든 과일을 빨간색으로 칠해라” 같은 명령을 **통째로 동시에 적용**하는 거야. 모든 가능성을 한꺼번에 계산하고, 마지막에 똑똑하게 측정해서 우리가 원하는 답을 꺼내는 시스템
“모든 가능성을 동시에 계산하려면, 그 각각의 결과를 어딘가에 ‘기록’해야 할 텐데? 그런데 왜 ‘측정’ 하나로 결과를 꺼낼 수 있어?
- **기록하는 게 아니라, “확률 진폭(amplitude)“로 상태를 조작하는 거야.**
- “모든 가능성(**모든 입력에 대해 결과를 동시에 표현하는 것**)에 확률을 걸어두고, 그 무늬를 조작해서, 측정할 때 원하는 답이 나오게 확률 조정하는 거야
슈뢰딩거 고양이 느낌으로 까기전엔 뭔지 모르게 위장..?
그냥 실시간으로 스스로 암호변경하게 하면 되지않을까?
양자컴퓨터는 모든경우의수를 펼쳐내고 최적의 답을 높은 확률로 튀어나오게
- 수학적으로 **좋은 답 쪽은 파동을 강화**하고, **나쁜 답 쪽은 파동을 약화**시킴
- 그 다음 “한 번” 측정해서 높은 확률로 정답을 끄집어냄
- 모든 가능한 상태를 겹쳐: 0, 1, 2, 3, 4, 5, …, 1023  (예: 10비트면 1024가지) **한 번에** 만들어놓음.
- “좋은 답”에는 +1 신호를,
- “나쁜 답”에는 -1 신호를 주는 **오라클 함수**를 만들고 
- **정답 후보는 확률을 점점 높이고**, **틀린 후보는 확률을 깎는다.**
- 슈퍼컴퓨터는 다 확인해서 제일 좋은거 맞추는거고 양자컴퓨터는 다 확인하는건 아니지만 높은 확률로 이거일듯? 하는거


- 양자컴퓨터의 약점
	- 이전결과를 알아야 다음계산을 할수있는경우
	- 



| **강해야 할 것**                                        | **왜 필요한지**    |
| -------------------------------------------------- | ------------- |
| 고전 컴퓨터 시스템 이해 **양자컴퓨터는 고전컴퓨터를 대체하지 못해.**           | 양자가 못하는 영역 유지 |
| 양자 활용 분야 (**최적화 문제, 암호해독, 시뮬레이션, 머신러닝** 이쪽만 가속함)구분 | 효율적 기술 적용     |
| 양자 내성 암호 지식                                        | 양자 해킹 대비      |
| 수학적 사고 (선형대수, 확률)                                  | 양자 알고리즘 이해    |
| 시대 흐름 감지 능력                                        | 기회 선점         |
근데 **“고전 컴퓨팅 + 양자 컴퓨팅”을 동시에 쓰는 구조**야.  필요한 순간에만 양자 처리, 나머지는 기존 방식으로 처리! 하는 하이브리드 컴퓨터..가 연구중,.

# **🚀** 

# **미래 백엔드 개발자의 “진짜 스킬”은?**

- 1. 고전 서버를 튼튼히 짜는 능력 (기본)
        
    
- 2. 양자 가속 API를 설계하는 감각
        
    
- 3. 고전-양자 데이터를 변환하거나 동기화하는 센스
        
    
- 4. 보안에 대한 감각 (특히 Post-Quantum Cryptography)
        
    
- 5. 실패 가능성 높은 양자 연산 대비 에러 복구/재시도 로직 설계