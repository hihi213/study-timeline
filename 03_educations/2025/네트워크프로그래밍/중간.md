- 수업은 c로 진행하는데, 나는 c++로 진행하기로 했다
- c++ <- c변환
```c++
	#include <iostream> //<stdio.h>
	#include <cstdlib> //<stdlib.h>
	#include <cstring> //<string.h>
	//printf("Usage : %s <IP> <port>\n", argv[0]);
	 std::cerr << "Usage : " << argv[0] << " <IP> <port>" << std::endl;
	 //fputs(message, stderr); fputc('\n', stderr);
	 cerr << message<<endl;
```
- cout vs cerr: 실행하면 콘솔에 둘다 보임 근데 에러, 정상출력을 분리해서 지정하면 분리한대로 파일에 저장을 따로 할수있음
	- std::cout은 **정상 메시지** 출력용 (예: 프로그램 결과)
		- ./program 1> output.txt
		- 이러면 output파일에 정상출력 기록만 저장
	- std::cerr은 **에러 메시지** 출력용 (예: 오류 로그)
		- ./program 2> error.txt
		- 이러면 error파일에 에러기록들 만 저장됨
- telnet는 보안문제로 x 
	- nc ::1 9000
		- 이걸로 대체하거나, 직접만든 client 코드를 사용

- 내가 새로 알아둬야할것
	- #### 1. sockaddr(함수 인터페이스)
		- 이건 주소 체계가 달라도 sockaddr* 하나로 처리 가능하게 하기 위한 인터페이스
		- sockaddr_in-> IPv4 주소를 담는 구조체
		- sockaddr_in6-> IPv6 주소를 담는 구조체**
	- #### **2. sockaddr_in — IPv4 주소를 담는 구조체**
		```c++
		struct sockaddr_in {
			자료형            변수명
			sa_family_t    sin_family;   // 주소 체계 (IPv4인지 등)
			in_port_t      sin_port;     // **포트 번호**. htons()로 네트워크 바이트 순서로 변환 필요
			struct in_addr sin_addr;     // IP 주소담는 구조체 3번참고
			char           sin_zero[8];  // 의미 없음. **구조체 크기 맞추려고 넣은 더미 공간**
		};
			```
	- #### **3. in_addr — 실제 IP 주소를 저장하는 구조체**
		```c++
		struct in_addr {
			uint32_t s_addr;  // 실제 IP 주소 (4바이트)
		};
		
		```
		- _addr 하나밖에 없는데 왜 굳이 구조체로 감싸지?”
			- 모든 네트워크 주소 처리 함수들 (bind, connect, sendto, …)은주소 정보를 받을 때 구조체를 요구합니다. 📌 그래서 내부 값이 단 하나여도 in_addr이라는 구조체로 감싸두면 함수 시그니처(인터페이스)를 통일**할 수 있어요.
			
			- 그리고 지금은 하나뿐이지만 **나중에 확장할 가능성을 대비**해서 구조체로 만들어 놓은 거예요.
	

- int main(int argc, char* argv\[])
	- argc: **argument count**: 인자의 개수 (정수형)
	- argv\[]: **argument vector**: 인자 목록 (문자열 배열)
	- ./Server 9000 이렇게 실행시
		- argc에는 2, argv={"./Server", "9000"} 이렇게 저장됨



- int 변수명 = socket(PF_INET, SOCK_STREAM, 0); //TCP 소켓 생성코드
	- PF_INET: **IPv4 프로토콜 사용** (인터넷 주소 체계)
	- SOCK_STREAM: **TCP 통신 사용** (연결 기반, 신뢰성 보장)
	- 0: 기본 프로토콜 사용 (TCP면 자동으로 TCP 사용됨)
	- 이때 int변수에 저장하는건 소켓 식별번호
		- 소켓 생성 성공:  3이상의 숫자를 반환(소켓식별자)
			- - > **0, 1, 2는 이미 표준 입출력용으로 운영체제가 예약해**놓음
		- 소켓 생성 실패: -1를 반환

- 




**✅ 소켓 프로그래밍에서 헷갈릴 수 있는 타입 & 구조체 & 상수 총정리**

| **이름**             | **한줄 요약**       | **분류**        | **의미**                             | **자주 헷갈리는 포인트**                     |
| ------------------ | --------------- | ------------- | ---------------------------------- | ----------------------------------- |
| int                | 소켓 번호           | 기본 타입         | 파일 디스크립터 (소켓 번호로 사용됨)              | 그냥 정수처럼 보이는데 사실 시스템에서 소켓을 식별하는 ID임  |
| socklen_t          | 주소 크기 정수        | 타입 (typedef)  | 소켓 주소 구조체의 **길이(크기)**를 나타내는 정수형 타입 | int처럼 생겼지만 의미가 다름                   |
| struct sockaddr_in | IPv4용 주소 구조체    | 구조체           | IPv4 주소를 저장 (포트, IP 포함)            | struct sockaddr와 비슷해서 혼동됨           |
| struct sockaddr    | 주소의 부모형태        | 구조체           | 주소의 일반형(모든 주소를 담기 위한 범용 구조체)       | 진짜 주소는 sockaddr_in인데 함수 인자에는 얘를 씀   |
| AF_INET            | IPv4 주소 체계      | 상수 (주소 체계)    | IPv4 인터넷 주소 체계                     | PF_INET과 헷갈리기도 함                    |
| PF_INET            | IPv4 프로토콜 계열    | 상수 (프로토콜 패밀리) | IPv4 프로토콜 계열                       | AF_INET과 거의 동일하게 사용되지만 의미가 살짝 다름    |
| SOCK_STREAM        | TCP용 소켓         | 상수 (소켓 타입)    | TCP 소켓 (연결지향 스트림)                  | UDP랑 어떤 차이인지 헷갈림                    |
| SOCK_DGRAM         | UDP용 소켓         | 상수 (소켓 타입)    | UDP 소켓 (비연결지향 데이터그램)               | TCP랑 비교됨                            |
| INADDR_ANY         | 서버에서 모든 IP 수신   | 상수 (IPv4 주소)  | “모든 IP에 대해 바인딩”을 의미 (0.0.0.0)      | 실제 주소 아닌데 주소처럼 보임                   |
| htons() / ntohs()  | 바이트 순서 맞춰줌      | 함수            | 호스트 ↔ 네트워크 바이트 오더 변환               | 안 쓰면 통신 안 되는데 왜 쓰는지 모르겠는 경우 많음      |
| struct in_addr     | IP 주소만 따로 저장    | 구조체           | IP 주소를 저장하는 구조체 (s_addr)           | sockaddr_in 안에 들어가 있어서 따로 의미 파악 어려움 |
| struct in6_addr    | IPv6 주소용 구조체    | 구조체           | IPv6 주소 구조체                        | in_addr의 확장 버전인데 덜 익숙함              |
| bind()             | 주소를 소켓에 묶음      | 함수            | 소켓에 IP와 포트 연결                      | connect()랑 의미가 헷갈릴 수 있음             |
| connect()          | 상대 서버에 연결 시도    | 함수            | 서버와 연결을 시도함                        | bind()랑 혼동 많음                       |
| listen()           | 연결 요청 받을 준비     | 함수            | 서버 소켓을 “수신 대기 상태”로 전환              | 안 쓰면 accept()가 안 됨                  |
| accept()           | 연결 수락 후 새 소켓 생성 | 함수            | 연결을 수락하고 새로운 소켓 반환                 | 기존 소켓이 아니라 **새 소켓**을 반환하는 것에서 혼동    |

- 
	**✅ 구조적으로 헷갈리기 쉬운 예시**
	
	```
	// 서버 주소 저장용 구조체
	struct sockaddr_in serv_addr;
	
	// 이 구조체의 크기를 나타내는 socklen_t 타입 변수
	socklen_t serv_len = sizeof(serv_addr);
	
	// 실제 bind()나 accept()에서는 이렇게 씀
	bind(sockfd, (struct sockaddr*)&serv_addr, serv_len);
	```
	
	• sockaddr_in은 실제 주소 정보
	
	• sockaddr은 함수의 **형식에 맞추기 위한 형 변환용**
	
	• socklen_t는 그 구조체의 크기
	
	**✅ 추천 암기 키워드**
	
	• **sockaddr_in**: in → **Internet 주소(IP)**
	
	• **socklen_t**: len → **length(길이)**
	
	• **SOCK_STREAM**: stream → **연결지향 (TCP)**
	
	• **SOCK_DGRAM**: datagram → **비연결지향 (UDP)**

	---
	
**✅ 자주 헷갈리는 개념 요약표**

|**개념 구분**|**내용**|**헷갈리는 이유**|
|---|---|---|
|주소 체계 vs 프로토콜 계열|AF_INET vs PF_INET|거의 같지만 의미가 다름 (주소 vs 프로토콜)|
|주소 구조체|sockaddr_in vs sockaddr|하나는 실제 데이터, 하나는 범용형|
|TCP vs UDP|SOCK_STREAM vs SOCK_DGRAM|모두 소켓이지만 동작 방식 완전히 다름|
|주소 vs 주소 길이|sockaddr_in vs socklen_t|하나는 구조체, 하나는 정수형|
|소켓 함수 역할|bind(), connect(), accept()|각각 언제 쓰는지 처음엔 헷갈림|


- 여기부터 정리 시작

- 소켓이란? IP 주소 + 포트 번호 + 프로토콜**을 내부에 가진 객체
	- 서버 입장에서 네트워크 통신을 위한 입구이자 통로

```
클라이언트:
1. socket()     → 소켓 생성 (내부 통로 준비) 
2. connect()    → 상대방 주소로 연결 요청 (문 두드림)

서버:
1. socket()     → 입구 준비 (대기줄서는 문)
2. bind()       → 주소에 입구 설치
3. listen()     → 입구 열고 기다림
4. accept()     → 입장 허락시키고 서버가 그 클라이언트 소켓을 새로 만들어 실제 거래하는 문을 만들어준다

```

- socket() :   IP/TCP 통신을 위한 “빈 소켓 객체” 생성
	- 입구 구조를 만든다
	- **내부 동작**:
	    - 커널이 struct socket 구조체 생성
	    - 여기에 프로토콜 (AF_INET / SOCK_STREAM 등) 정보 등록
	    - 사용자에게 파일 디스크립터(sockfd)로 반환
- bind(): 소켓에 IP주소와 포트번호를 “묶는다” (struct inet_sock 내부에 등록) 
	- 서버에서만 실행
	- 즉, 네트워크 상에서 이 소켓이 **“어디서 온 것인지”를 명확히 지정**하는 것.
	- 입구를 “어디에 설치할지” 지정
	- 커널 내 inet_sock 구조체에 IP/Port 정보를 설정
    - 이후 해당 주소로 데이터가 들어오면 이 소켓이 담당
	- **없으면 생기는 문제**:
		- bind() 안 하면 커널은 어떤 IP/포트로 대기할지 알 수 없어서 listen() 호출 자체가 실패하거나 accept() 시 연결을 받지 못함 → **접속 받을 주소가 없으니 기다릴 대상도 없음**
	    - 클라이언트에서 안쓸때: 이게 없으면 connet()호출시 커널이 확인후  자동으로 설정한다 
	    - **클라이언트는 “어디서 보내는지”보다 “어디로 보내는지”가 중요해서 bind()는 커널이 대신 해줘도 되고,** **서버는 “어디서 받을지”를 정확히 정해놔야 하니까 반드시 bind()가 필요**
	- 실습에서는 특정ip만 받게 제한할 이유가 없으니 server_addr.sin_addr.s_addr = INADDR_ANY; 으로한다 
- listen(): 서버 소켓을 “연결 요청 대기 상태”로 전환 (TCP 상태 LISTEN)
	- 서버에서만 실행
	- 입구 앞에 줄 설 수 있게 열어둠
	- 커널이 내부 큐를 만들고, 클라이언트가 이쪽으로 SYN 보내는 걸 받기 시작함
	- **내부 동작**:
	    - tcp_sock 상태를 LISTEN으로 전환
	    - 커널이 들어오는 SYN 요청을 큐에 저장할 준비를 함
	- **없으면 생기는 문제**:
	    - 클라이언트가 연결 요청을 보내도, 서버는 응답하지 않음
- connect() : 클라이언트가 서버 Ip/port로 실제 tcp연결 시도
	- **클라이언트가 서버 쪽 “입구”로 찾아가서 문을 두드리는 행동이야.** 즉, 클라이언트 입장에서 connect()는 **“나 여기 왔어, 이 주소(IP:PORT)로 연결하고 싶어!”** 라고 요청
	- **내부 동작**:
		- bind() 자동 호출 (필요한 경우)
		- SYN 패킷 생성 및 송신
		- 연결이 성공하면 상태가 ESTABLISHED가 됨
	- **없으면 생기는 문제**:
		- 서버에 연결 자체가 안 되며 send/recv는 오류 발생
- accept():  연결 요청 큐에서 하나 꺼내서 “새로운 1:1로 연결될 소켓”을 반환
	- 입장 심사 통과한 클라이언트에게 전용 문(ip+port)을 열어주는 함수
	- **내부 동작**:
	    - 새로운 struct socket / inet_sock / tcp_sock 세트를 생성
	    - 커널이 클라이언트와의 연결 상태(TCP ESTABLISHED)를 관리하는 소켓을 만들어 줌
	    - int client_fd = accept(server_fd, ...);
	    - 이 시점부터는 client_fd가 **클라이언트와의 1:1 연결 전용 소켓**이 되고, server_fd는 계속 입구 역할만 유지해
	- **없으면 생기는 문제**:
		- 클라이언트가 connect()로 요청은 보내지만, 서버가 accept()를 호출하지 않으면 이걸 호출하지 않으면 **클라이언트는 연결되었다고 느끼지 못해 기다리다 결국 timeout 됨**.

<여기서  연결된 클라이언트 수가 많아지면 결국 **1:1 연결된 소켓이 그만큼 많아진다**>
- 서버 혼자 한명씩 처리하고 다음처리하는건 너무 느려-> 동시에 처리할 구조가 필요해
- fork(): 서버가 자신의 프로세스를 복제
	- 한 서버가 여러 클라이언트 소켓을 **직접** 다루는 게 아니라
	- accept()로 생긴 **1:1 연결 소켓(client_fd)** 수만큼 fork()로 **서버 자식 프로세스를 생성해서** 각 자식에게 **그 클라이언트 소켓을 전담시킴**
	- 부모(원래 서버)는 자기가 지켜보던 **listen_fd만 유지해** 계속 입구에서 새로운 요청을 받음
- thread 방식: 서버가 **자식 프로세스가 아닌 스레드를 복제** (fork와 차이점)
	- 서버는 accept()로 연결된 client_fd를 받고,
	- 클라이언트마다 **pthread_create()로 스레드를 생성해서**,
	- 해당 스레드에게 **그 클라이언트 소켓을 맡김**
	- 스레드를 복제하는거라 공유자원 처리 필요
- select():  서버가 하나의 루프에서 **모든 1:1로 연결된 소켓들을 감시하며**, **지금 읽을 준비가 된 소켓만 찾아서 처리**
	-   다만 내부적으로는 **매번 모든 소켓 상태를 다시 설정하고 스캔하기 때문에**, **클라이언트 수가 많아질수록 선형적으로 느려짐**
- epoll(): 커널이 이벤트가 발생한 소켓만 알려주는 방식
	- 서버는 모든 연결된 소켓들을 epoll에 등록해두고, epoll_wait()를 통해 이벤트가 발생한 소켓만 골라서 처리함
	- 커널이 준비된 소켓만 알려줘서, 불필요한 반복 없이 효율적

<프로세스와 스레드의 차이>
- os가 하는 관리의 연산거리 단위
	-  연산실행단위: **운영체제가 자원을 묶어 관리하는 단위 = 프로세스**
		- 멀티태스킹
	-  연산흐름단위:  **CPU가 실제로 실행흐름을 쪼개서 실행하는 단위 = 스레드**
		- 멀티스래딩
	- process(작업)은 최소 1개의 thread(연산)존재
	- 연산: 운영체제(os)가 CPU+ 연습장(RAM)대신 가상메모리를 '프로세스'에게 지정해줌
		- 직접 Ram(1차메모리) 를 피지컬로 접근하는게 아니라
		- 가상메모리(Ram+HDD(2차메모리))로 접근
		- 즉 가상메모리를 따라가면 Ram이아니라 HDD가 나올수있다 램인줄 알고 쓰렴~
	- 스레드는, 작동범위의 영역이 가상메모리 안이다. 즉 프로세스에 속한 모든 스레드는 프로세스의 가상 메모리안으로 공간이 제약된다.
		- 그래서 동시성과 동시화 이슈가 따른다
		- 스레드는 각자 동시에 실행되는데, 가상메모리안의 각자의 공간(스레드로컬스토리지 TLS)을 제외한 나머지 공유공간도 공유해서 데이터가 덮어씌어질수있다.
	- 스레드는 프로세스의 실질적 연산 주체,단위
	- 할일의 양을 3번 쪼개서 한팀인 3명이 하라고 하는게 나을까
		- 가상메모리 하나를 나눠서 써라
	- 각자 3명일 할꺼냐
		- 각자 가상메모리 주기
	- 멀티스레드: 그냥 한 프로그램에서 하나를 짧게하고 저장하고 다른하나로 바꿔서 불러오고 조금하고 저장하고 조금씩 바꿔서 하는거야
		- 왜 스레드를 생성해야함? tmp변수로 바꿔가면서하면 되잖아
			- ->이건 수동 컨테스트 스위칭이야
			- 내가 일일히 코드 다 짜줘야함
			- 그리고 하나의 흐름안에서 번갈아가는 흐름만 가능(동시에 파일쓰기/입출력처리...불가)
			- 스레드는 이걸 자동으로 해주는 장치이자, 서로 독립된 실행흐름 만들어줌
		- 스레드란? -> 코드이다
			- 운영체제(OS)나 라이브러리에 미리 준비된 누가 이미 짜놓은 코드,
			- 하나의 작업 흐름(실행 흐름)을 만들고 관리하는 코드
		- 스레드생성이란? 스레드관리 코드를 호출해서 스레드의 시작점을 등록하고, 실행 흐름을 하나 더 만드는 것
	- 멀티코어: 실제로 병렬처리


- 자바에서의 함수는 객체의 메서드일뿐이라서 “함수를 고정하지 않고, 다양한 함수 중 상황에 따라 다른 걸 하나의 변수 이름으로 실행하고 싶을땐 인터페이스를 이용해서 객체처럼 다뤄야하지만
- c/c++에서는 함수이름 자체가 시작주소라 함수이름을 함수포인터에 넘겨주면 된다.

- 함수 호출하면 운영체제가 스택크기를 할당해 스택을 자동으로 만들어주지만, 운영체제는 코드를 읽기/이해/판단하는게 아니라 자원분배쪽이라 “어떤 코드가 실행될지”와 “어떤 입력이 들어올지”를 알 수 없기 때문에, 운영체제는 프로그램이 얼마나 많은 스택을 쓸지 알 수 없기 때문에, 프로그램이 필요하면 미리 스택 크기를 설정해서 요청해야 한다 
- 스레드 함수
	- pthread_create(스레드 id저장할 변수(식별/관리), 스레드속성설정, 스레드가 실행할 함수의 시작 주소, 그 함수로 넘겨줄 외부 데이터 포인터(스레드 각자 다른 데이터기반으로 일하게해줌 - > 만약 이게 없으면 똑같은 함수만 N번 호출될 뿐 각자 다른 일을 할 수 없음))
		- pthread_t \* 타입은 os마다 스레드 id가 int일수있고 구조체일수있어서 추상화한 타입
	- pthread_join(기다릴 스레드의 ID, 스레드가 return한 값 받아올 포인터(이중 포인터인 이유는 스레드가 값의 주소를 리턴하는것이라서 즉 포인터를 받는 이중포인터 이때포인터의 타입은 어떤 타입의 값일지 모르니 void))
		- join를 호출한 스레드가 매걔변수로 지정한 스레드가 끝나면 그 스레드를 관리하던 리소스 정리(회수)하고 그다음 줄 코드 실행
		- **지정한 스레드의 리소스를 회수하는 게 주 목적이고, 그걸 위해 ‘끝날 때까지 기다리는’ 게 부수적으로 필요한 것이다.**
			- 스레드 끝나도 운영체제 메모리, 커널리소스를 차지하는 좀비 스레드로 남게 됨
			- 이걸 join()해서 회수하거나
			- pthread_detach()로 끝나는 스레드가 스스로 자원을 회수하게 만들어야 해.
		- 함수 리턴타입 void : 아무것도 반환하지 않는다.
		- 포인터타입에서의 void : 자료형이 없음
			- void \* : 주소를 담은, 읽거나 쓸수없는 타입의 값을 가리키는 포인터
				- void자료형에는 그냥 숫자인 주소값만 저장하는건 가능해
			- void \*\*: void\*을 가리키는 포인터
			- void\* 는 다 받을 수 있지만, 그 값을 읽거나 수정하기위해 참조하려면 “타입은 이거이니 이 크기만큼 읽어라“라고 명시적 형변환을 해줘야 한다.
		-  **스레드는 값이 아닌 메모리 주소를 반환해야하는데, 종료시 스택이 사라지기 때문에, 리턴할값을 힙에 저장해야한다.** 
			- 스레드는 범용적으로 만들어야해서 타입 신경끄려고 void\*타입만 주고받아 반환값이 void\*이다. void\*  이거는 그냥 주소다. 타입이 안들어간 주소를 반환하는거다
				- void \* 가 가리키는 값: 순수한 주소 그 자체(타입 명시 x)
				- int \*: int크기만큼 읽어야하는 값을 저장한 변수를 가리키는 포인터
			- 스레드가 끝나도 살아있을 힙(heap) 영역에 결과를 만들어놓고(malloc),그 힙 메모리의 주소를 리턴한다.
				- 스택은 지역변수로 스레드 함수가 끝나면 사라진다. 힙에 만들어야 메인스레드가 스레드가 끝나도 사용가능하다.
				- 만약 스레드 함수 안에서 지역변수 주소를 리턴하면? 그 함수 끝나면 그 스택은 **무효(날아감)** → 결과가 이상해짐.
			- 그래서 pthread_join()이 이 주소를 이중 포인터(void \*타입)로 받아야 하고,
			- 이때 힙 메모리 주소는 void* 타입이기 때문에, **몇 바이트를 읽어야 할지, 어떻게 해석해야 할지 모른다** .그래서 원래 타입(int*, char*, struct* 등)으로 형변환해서 사용해야 정상적으로 메모리 읽고 쓸수있다.
				- void는 메모리 주소만 있다
				- 다른타입은 몇바이트를 읽어야한다는 정보가 추가적으로 있다 
				- 캐스팅은 단순히 문법적 요구사항이 아니라, **CPU가 메모리 해석할 방법을 알게 해주는 행위**야.
			- 사용을 끝냈으면 free()로 힙 메모리를 수거한다.
- 리눅스에서 스레드를 종료하는 4가지 방법
	- 스레드 함수가 return문을 만나 반환하며 정상 종료
		- 이때 pthread_join으로 받아옴
	- 스레드 함수안에서 pthread_exit() 함수를 호출해 스스로 종료
		- 이때  pthread_exit(포인터); 하면 pthread_join으로 받아옴
	- 스레드가 pthread_cancel()를 호출해 지정한 스레드에 취소 요청 보냄 
		- 바로 죽지 않고 취소가능 지점에서 리턴없이 종료
		- 스레드가 “블로킹되거나”, “잠시 멈춰서 대기하는 함수 호출 중에서 종료
			- sleep(1)
			- read()
			- 스레드가 취소 가능 지점 없이 CPU를 막 돌리고 있으면, **취소 요청을 무시한 채 계속 살아 있을 수도 있어!**
				- 그래서 필요하면 끊고 싶은 중간에 pthread_testcancel(); 명시
	- 메인 스레드가 종료 (프로제스 내의 다른 모든 스레드 또한 리턴없이 강제종료됨)

- typedef :  타입 별명만들기 (type+ define)
	//typedef 타입 변수명;
	//타입명에 별명을 만들어줌 이제부터 ui a;로 변수선언 가능
		typedef unsigned int ui;
	
	//자 여기서 struct Point3D 자체가 타입이다. struct만 달랑 타입이 아니라
		typedef struct Point3D{
		int x,y,z;
		}Point3D;
- 스레드와 테스크 차이
	- **스레드 수 : 동시에 처리할 수 있는 묶음 수**
	- **테스크 수 : 해야 할 일 수**
- 스레드 우선순위
	- 우선순위 정책은 2가지 이걸 둘다 운영 -> “운영체제는 항상 실시간 스레드부터 먼저 돌리고, 없으면 정규 스레드를 공평하게 돌린다
	- 1~99범위의 우선순위를 지원하는 실시간 스케줄링 정책
		- 실시간 급한 프로그램은 우선순위 1~99를 쓴다. 숫자가 클수록 더 급하다
	- 우선순위 0을 가지는 정규스케줄링 정책 (우선순위 숫자가 작다-> 우선순위가 높다 우선순위가 높을수록 먼저 cpu받음)
		- 우선순위를 따로 명시하거나 강제하지 않는 **일반 프로그램들**을 처리하기 위해 만들어진 기본 규칙 그래서 일반 프로그램은 우선순위 0으로 통일해 다룸
		- **정규 스케줄링은 “우선순위 부여를 안한” 프로그램끼리 다 같이 공평하게 돌리려고 만든 거야**
	- **일상에서는 높다/크다 대충 섞어 쓰지만, 리눅스에서는 **nice 값이 작을수록** 실제 CPU 우선순위(내부 숫자)가 작아져서 더 빨리 CPU를 배정받는다.”
	- nice() :우선순위 변경방법
		- Nice()는 기존우선순위에 -20~+19를 더해주고 결정된 우선순위 값을 리턴한다.
			- 범위가 40인 이유는 엄청 급해서 Nice로 수정 못하는 우선순위 단계가 100이라서 (실제 프로세스 우선순위는 0~139-> 여기서 우리가 갖고 놀 일반 프로세스범위는(100~139))
		- errno는 '전역'변수다 '마지막으로 호출한 함수가 에러가 발생했을때 자기 스레드 전용 전역변수 errno에 에러코드를 저장'
			 - 스레드마다 독립적인 errno 변수
				 네가 pthread_create()로 스레드를 만들 때,
				- 운영체제와 C 라이브러리가 스레드 전용 데이터 구조(Thread Local Storage, TLS) 를 만들어줘.
					- 프로세스마다 스택(지역변수 저장)이 있듯이 스레드마다 따로 가진 저장 공간를 TLS라고 함(스레드 안에서는 전역처럼 접근할수있지만 스레드 밖에선 접근불가한 변수) 
				- 그 안에 errno도 포함되어 있어.
				- 그래서 우리가 따로 “errno 생성하겠다” 이런 코드 안 짜도 자동으로 스레드별 errno 준비되는 거야.
		- 이전에 에러가 있었던 흔적이 남아 있을 수도 있어서 errno를 0으로 초기화해 nice 호출결과를 판단할수있게 한다
- 0은 항상 값이지만, **포인터에 0을 넣으면 NULL 의미가 되고**, 일반 변수에 0을 넣으면 그냥 숫자 0이다
	- 변수가 포인터인경우 0를 메모리 주소 자체로 해석하기 때문에 NULL 즉 가리키는 대상 없다고 해석한다