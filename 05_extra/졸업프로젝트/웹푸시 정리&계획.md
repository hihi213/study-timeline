

## **WebSocket + PWA 웹푸시 vs FCM 푸시 알림 vs PWA 내부 알림(서비스 워커) 차이점**

- pwa: 앱의 구조일뿐 알
- 서비스워커: pwa 브라우저가 꺼져있어도 백그라운드에서 알림을 표시만 해주는 엔진(전송, 수신x)
	- 브라우저랑 별도로 백그라운드 스레드에서 동작
- 알림을 전송하는 구조
	- 연결된경우
		- webSocket: 브라우저가 닫혀있지 않고 열려있을때 데이터 전송, 수신
	- 백그라운드에도 가능
		- FCM는 앱이 열려있든, 백그라운드에 있든 서비스워커를 통해 서버에서 클라이언트로 알림을 보내주는 서비스이다 아이폰에서는 FMC 못쓰고 apns 써야해서 유료
		- **APNs** (유료)
		- **Web Push (VAPID)** (무료)
			- 서버에서 클라이언트로 일방적, 비동기적 알림전송


# 알림계획
- 접속중: webSocket
- 안드로이드 백그라운드: PWA+FCM
- 아이폰 백그라운드:  PWA+ webpush
	- 사용 종료임박알림
	- 다른유저의 세탁 수거 요청
	- 관리자의 공지(서버 점검시간, 모든 세탁기가 고장남 등의 미리 실시간으로 공지해야할 사항들 시간대 예약발송)
	- 아이폰에서
		- 홈화면에 추가(PWA설치)후 알림권한 허용해야 지원됨
		- 잠겨있거나, 절전모드이거나 완전히 닫혀있어도 웹푸시 보낼수있음
		- 푸시 구독 토큰이 주기적으로 만료되어, 사용자가 재등록해야 하는 경우
		- iOS는 **백그라운드 동기화(Background Sync)**를 지원하지 않으므로, 푸시 알림 외의 백그라운드 작업은 불가합니다
		- Silent Push(무음 알림)은 지원하지 않아, 모든 알림이 반드시 사용자에게 표시됩니다
			- 관리자가 공지할때 소리나게 설정할지,시간대고려해서 전송할수있도록
	- 안드로이드
		- 절전모드일시: 전달 안될수있음
			- 반면 FCM이면 high priority설정하면 전달가능
- 접속할때(websocket)
	- 사용등록시작 알림
	- 관리자의 공지(기기 수리완료/ㅇㅇ기기 고장공지/수리공지 등 실시간으로 사용할 기기와 관련하여)
- 



# 구현계획

**Service Worker 파일 생성 → VAPID Key 생성 → Subscription Endpoint 저장 → 알림 전송 → 클릭 시 앱 열기**의 순서로 구성

https://www.youtube.com/watch?v=JVMiTexyp6U

### **✅** 

### **영상 내용 요약 및 해석**

  

### **영상 개요**

  

이 영상은 **PWA(Public Web Application)에 웹 푸시 알림(Web Push Notification)을 구현하는 방법**을 단계별로 설명하는 내용입니다. 왼쪽은 Chrome에서 실행되는 애플리케이션이고, 오른쪽은 iOS 기기에서 실행되는 애플리케이션입니다.

사용자는 PWA에서 알림을 승인하거나 거부할 수 있으며, 알림을 클릭하면 앱이 열립니다.

---

### **1. 푸시 알림 예제 동작 시연**

- Chrome에서 **승인(Approve)** 버튼을 클릭하면 푸시 알림이 iOS 기기로 전송됨.
    
- iOS 기기에서 푸시 알림을 클릭하면 앱이 열리며, 이는 **네이티브 앱처럼 동작**함.
    
- 반대로 iOS 기기에서 승인 버튼을 클릭하면 푸시 알림이 Chrome으로 전송됨.
    

  

**적용 사례:**

- 채팅 애플리케이션에서 **메시지 수신 시 알림**을 보내는 데 유용함.
    

---

### **2. 웹 푸시 알림 구현 개요**

- **1단계:** Service Worker 등록
    
    - Service Worker는 백그라운드에서 실행되며, 앱과는 별도의 스레드에서 동작함.
        
    - 푸시 알림, 오프라인 캐싱 등의 기능을 제공함.
        
    - 앱의 수명과 무관하게 동작하므로, 백그라운드에서 알림을 전송할 수 있음.
        
    

  

**구현 과정:**

- 앱 내에서 Service Worker를 등록함.
    
- 등록이 완료되면 **Subscription Endpoint**가 생성됨.
    
    - 이 Endpoint는 브라우저마다 다름.
        
    - 이 Endpoint를 사용자 테이블에 저장하여, 나중에 이 Endpoint를 통해 푸시 알림을 전송할 수 있음.
        
    

---

### **3. 서비스 워커 등록 확인**

- Service Worker가 제대로 등록되었는지 확인하는 방법:
    
    - Chrome: Application > Service Worker 탭에서 확인 가능.
        
    

---

### **4. PWA로 변환**

- 이 애플리케이션은 **Next.js**로 개발됨.
    
- Next-pwa라는 패키지를 사용하여 PWA로 변환.
    
    - next-pwa에서 destination을 public 폴더로 설정하고, register 옵션을 true로 지정함.
        
    

---

### **5. 알림 요청 컴포넌트 구현**

- NotificationRequest 컴포넌트 생성
    
    - 두 가지 상태: **Bell Off(알림 꺼짐)**, **Bell Ring(알림 켜짐)**
        
    - 사용자가 Bell Off 버튼을 클릭하면 알림 허용 여부를 묻는 창이 뜸.
        
    - 허용하면 granted 상태가 되고, SubscribeUser 함수가 호출됨.
        
    

---

### **6. 사용자가 알림을 거부한 경우**

- 사용자가 Block을 클릭하면 알림을 받을 수 없음.
    
- 사용자가 거부한 알림을 다시 승인하려면,
    
    - 사용자가 **브라우저 설정에서 수동으로 알림을 활성화**해야 함.
        
    

---

### **7. 푸시 알림을 구독(Subscription)하는 과정**

- SubscribeUser 함수가 실행됨.
    
- Service Worker가 등록되었는지 확인한 후, Subscribe Endpoint를 생성함.
    
- VAPID Key가 필요함:
    
    - VAPID Key는 **서버와 클라이언트 간의 인증을 위한 공개키/개인키 쌍**임.
        
    - 이 키를 통해 서버는 특정 클라이언트에만 알림을 전송할 수 있음.
        
    

---

### **8. VAPID Key 생성**

- web-push 라이브러리를 사용하여 VAPID Key 생성 가능.
    
    - 생성 시 public key와 private key가 함께 생성됨.
        
    - public key는 클라이언트에 저장하고, private key는 서버에서만 사용해야 함.
        
    

---

### **9. 구독 Endpoint 저장**

- 생성된 Subscription Endpoint는 notification 테이블에 저장됨.
    
- 이를 통해 사용자가 승인한 기기에서만 푸시 알림을 받을 수 있도록 함.
    

---

### **10. 푸시 알림 전송**

- 서버에서 web-push 패키지를 사용해 푸시 알림을 전송함.
    
- 알림 전송 과정:
    
    1. 사용자 Endpoint를 데이터베이스에서 가져옴.
        
    2. web-push.sendNotification() 함수를 호출하여 알림 전송.
        
    3. 알림 메시지에는 title, body, icon이 포함됨.
        
    

---

### **11. Service Worker에서 푸시 알림 수신**

- Service Worker 파일 내에서 push 이벤트와 notificationclick 이벤트를 처리함.
    
    - push 이벤트: 서버에서 보낸 알림을 수신할 때 트리거됨.
        
    - notificationclick 이벤트: 사용자가 알림을 클릭했을 때 트리거됨.
        
    

---

### **12. 알림 이벤트 핸들링**

- push 이벤트에서 알림 메시지를 파싱하고, 알림을 표시함.
    
- notificationclick 이벤트에서 사용자가 알림을 클릭하면, 앱이 열리도록 설정함.
    

---

### **13. iOS의 제한사항**

- iOS의 경우, **버전 16.4 이상부터 웹 푸시 알림을 지원**함.
    
- 이전 버전에서는 웹 푸시 알림이 동작하지 않음.
    

---

### **14. 최종 구현 요약**

- 알림을 승인하거나 거부할 수 있는 컴포넌트 구현.
    
- PWA로 앱을 변환하고, Service Worker를 등록함.
    
- VAPID Key를 통해 서버와 클라이언트 간의 인증을 처리함.
    
- web-push 패키지를 사용하여 푸시 알림 전송.
    
- push 이벤트와 notificationclick 이벤트를 통해 알림과 클릭을 처리함.
    

---

### **✅** 

### **결론 및 피드백**

- 이 영상은 **PWA와 웹 푸시 알림의 구현 과정**을 매우 실용적인 예제로 설명하고 있음.
    
- iOS, Chrome 등 **브라우저별 제한사항**과 그 해결 방법도 함께 제시하여 실제 구현 시 도움이 될 만한 정보가 잘 정리되어 있음.
    
- VAPID Key 생성, Service Worker 등록 등 **보안 요소**에 대한 개념도 간단히 다루고 있어, 실무에서 유용하게 활용 가능함.
    

  

이제 이 내용을 바탕으로 **졸업 프로젝트에도 웹 푸시 알림을 적용**하거나, 더 나아가 **알림 관리 기능을 고도화**하는 방안을 생각해볼 수도 있습니다. 👍👍👍😊