-  RESTful API로 URL 표현
	- 웹의 자원(데이터, 객체 등)을 URL(엔드포인트)로 표현하고,
	HTTP 메서드(GET, POST, PUT, DELETE 등)로 자원에 대한 행동(조회, 생성, 수정, 삭제 등)을 명확하게 구분하는 설계 방식입니다.
	1. 예시: 자원(Resource) 중심 URL
		•	`/resources/:id/use`
			•	`resources`는 자원(예: 세탁기, 냉장고 등)
			•	`:id`는 특정 자원의 고유번호(예: 123)
			•	`/use`는 해당 자원을 “사용한다”는 의미의 동작
		•	`/studyrooms/:id/reserve`
			•	`studyrooms`는 자원(예: 스터디룸)
			•	`:id`는 스터디룸의 고유번호
			•	`/reserve`는 “예약한다”는 
	2. HTTP 메서드와 조합
		- POST /resources/123/use
			→ 123번 자원을 사용한다(사용 요청을 생성)
		- POST /studyrooms/5/reserve
			→ 5번 스터디룸을 예약한다(예약 요청 생성)
		- GET /studyrooms/5
			→ 5번 스터디룸의 정보를 조회
- 웹페이지 성능 최적화
	- 백엔드
		- 캐싱 전략
			- Redis를 사용해 사용자 세션 및 자주 접근하는 데이터 캐싱 (예: 사용자 프로필)
			- 캐시 TTL을 5분으로 설정해 DB 부하 70% 감소
		- DB최적화
			- Connection Pool 크기를 50~100으로 설정해 동시 연결 관리
		- 비동기 처리
			- 이메일 발송, 파일 처리 등 장시간 작업은 Celery로 비동기화
	- 프론트엔드
		- WebP 포맷 사용으로 이미지 크기 30% 감소
		- `<img>` 태그에 `loading="lazy"` 추가
		- 초기 번들 크기를 1MB 이하로 유지
		- Webpack의 SplitChunksPlugin 활용
		- 정적 자원(이미지, CSS, JS) CDN 서빙
	- 모니터링
		- Node Exporter로 CPU/Memory 사용량 모니터링
		- Grafana 대시보드에서 실시간 트래픽 시각화
	- 부하테스트
		- 400명 가상 사용자로 5분간 지속 테스트
		- 95번째 백분위 응답 시간 500ms 이하 목표



알림 기능
- 웹푸시
- 알림로그 저장
	- 로그아웃후 다시 로그인후에 그 사이에 전송된 알림 전달 가능하게

팝업을 분리하는게 아니라 내부요소를 변경하는게 성능면에서 좋다.



- NFC 태그에 고유 ID를 포함한 URL을 넣고
- /item/:id에 진입 시 서버 조회로 분기
- 존재 여부에 따라 register or detail로 이동

- 20대 기기의 6가지 상태를 표현하는 경우, 웹 성능과 관리 효율, 사용자 경험 측면에서 ‘공통된 기본 이미지에 덧그리기’ 방식이 더 유리합니다.
- 특히 오버레이를 CSS, SVG, Canvas 등으로 구현하면 네트워크 요청과 용량을 줄이고, 상태 변경 시 빠른 반응성을 제공할 수 있습니다.

- Lazy Loading(지연 로딩) 적용으로, 화면에 보일 때만 이미지를 불러오게 하여 초기 로딩 속도를 개선할 수 있습니다
- 이미지는 웹사이트 용량의 대부분을 차지하므로, 압축과 적절한 포맷(JPEG, PNG, WebP, AVIF 등) 사용이 중요합니다
	- 이미지 압축 및 최적화: TinyPNG, Squoosh 등 도구로 용량을 줄이고, 품질 저하 없이 압축하세요
- 브라우저 캐시를 적극 활용해 반복 방문 시 리소스를 재사용할 수 있도록 합니다

- 불필요한 CSS/JS 코드는 제거하고, 여러 파일을 하나로 합쳐 요청 수를 줄입니다. 코드 압축(minify)도 필수입니다
- 렌더링 차단 리소스: CSS는 HTML 상단, JS는 하단에 배치해 렌더링 차단을 최소화하세요
- 비동기 로딩: JS 파일은 async/defer 속성으로 비동기 로딩해 DOM 렌더링을 방해하지 않게 합니다
- CSS 기반 애니메이션: JS보다 CSS로 애니메이션을 구현하면 리플로우·리페인트 발생을 줄여 렌더링 성능이 향상됩니다
- 불필요한 애니메이션 최소화: 과도한 애니메이션은 렌더링 성능 저하와 배터리 소모의 원인이 됩니다.

- 불필요한 DOM 요소 최소화: div 등 불필요한 태그는 제거해 DOM 트리의 복잡성을 줄입니다.
- 레이아웃 변경 최소화: 자주 위치가 바뀌는 요소, 크기 변동이 심한 UI는 렌더링 비용이 큽니다. 레이아웃 변경(reflow)을 최소화하세요

- 	•	브라우저 캐싱: 이미지, CSS, JS 등 정적 파일에 Cache-Control, Expires 헤더를 설정해 반복 방문 시 빠르게 보여줄 수 있습니다.
	•	서비스 워커(PWA): 오프라인 모드, 리소스 캐싱 등으로 모바일 환경에서 성능을 높일 수 있습니다

- 여러 svg아이콘을 하나의 SVG sprite로 묶어 사용하면, 이미지 요청 수를 줄여 성능을 높일 수 있습니다


- 미디어쿼리, 적응형 이미지로 불필요한 리소스 로드 방지
	- 미디어 쿼리
		-  CSS에서 기기 특성(화면 너비, 높이, 해상도, 방향 등)에 따라 다른 스타일을 적용하는 기술
	- 미디어 쿼리와 적응형 이미지를 활용하면, 데스크톱에서는 고해상도·큰 이미지를, 모바일에서는 저용량·작은 이미지를 각각 불러올 수 있습니다.
	- 예를 들어, `<picture>` 태그와 `srcset`, `sizes` 속성을 사용하면 화면 크기와 해상도에 따라 가장 적합한 이미지만 다운로드하게 할 수 있습니다
		- 화면 너비가 800px 이상이면 데스크톱용  고해상도·큰 이미지를, 그 이하면 저용량의 작은 이미지를 불러옵니다