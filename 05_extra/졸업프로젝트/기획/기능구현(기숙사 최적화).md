-  RESTful API로 URL 표현
	- 웹의 자원(데이터, 객체 등)을 URL(엔드포인트)로 표현하고,
	HTTP 메서드(GET, POST, PUT, DELETE 등)로 자원에 대한 행동(조회, 생성, 수정, 삭제 등)을 명확하게 구분하는 설계 방식입니다.
	1. 예시: 자원(Resource) 중심 URL
		•	`/resources/:id/use`
			•	`resources`는 자원(예: 세탁기, 냉장고 등)
			•	`:id`는 특정 자원의 고유번호(예: 123)
			•	`/use`는 해당 자원을 “사용한다”는 의미의 동작
		•	`/studyrooms/:id/reserve`
			•	`studyrooms`는 자원(예: 스터디룸)
			•	`:id`는 스터디룸의 고유번호
			•	`/reserve`는 “예약한다”는 
	2. HTTP 메서드와 조합
		- POST /resources/123/use
			→ 123번 자원을 사용한다(사용 요청을 생성)
		- POST /studyrooms/5/reserve
			→ 5번 스터디룸을 예약한다(예약 요청 생성)
		- GET /studyrooms/5
			→ 5번 스터디룸의 정보를 조회
- 웹페이지 성능 최적화
	- 백엔드
		- 캐싱 전략
			- Redis를 사용해 사용자 세션 및 자주 접근하는 데이터 캐싱 (예: 사용자 프로필)
			- 캐시 TTL을 5분으로 설정해 DB 부하 70% 감소
		- DB최적화
			- Connection Pool 크기를 50~100으로 설정해 동시 연결 관리
		- 비동기 처리
			- 이메일 발송, 파일 처리 등 장시간 작업은 Celery로 비동기화
	- 프론트엔드
		- WebP 포맷 사용으로 이미지 크기 30% 감소
		- `<img>` 태그에 `loading="lazy"` 추가
		- 초기 번들 크기를 1MB 이하로 유지
		- Webpack의 SplitChunksPlugin 활용
		- 정적 자원(이미지, CSS, JS) CDN 서빙
	- 모니터링
		- Node Exporter로 CPU/Memory 사용량 모니터링
		- Grafana 대시보드에서 실시간 트래픽 시각화
	- 부하테스트
		- 400명 가상 사용자로 5분간 지속 테스트
		- 95번째 백분위 응답 시간 500ms 이하 목표



알림 기능
- 웹푸시
- 알림로그 저장
	- 로그아웃후 다시 로그인후에 그 사이에 전송된 알림 전달 가능하게
